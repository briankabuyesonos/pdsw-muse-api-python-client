# muse_release_version: 1.24.0
from base_muse_websocket import BaseMuseWebsocket


# This class was automatically generated and should only be edited via muse-client.py.template
class MuseWebsocketClient(BaseMuseWebsocket):

    def __init__(self, ip, secure=True, hhid=None, uuid=None, apiKey=None,
                 subprotocols=None):
        super(MuseWebsocketClient, self).__init__(ip=ip, secure=secure, hhid=hhid, uuid=uuid, apiKey=apiKey,
                                                  subprotocols=subprotocols)

        self.alarms = alarmsClient(self)
        self.areas = areasClient(self)
        self.audioClip = audioClipClient(self)
        self.authorization = authorizationClient(self)
        self.clientStatus = clientStatusClient(self)
        self.devices = devicesClient(self)
        self.diagnostics = diagnosticsClient(self)
        self.entitlements = entitlementsClient(self)
        self.favorites = favoritesClient(self)
        self.global_ns = globalClient(self)
        self.groupVolume = groupVolumeClient(self)
        self.groups = groupsClient(self)
        self.hardwareStatus = hardwareStatusClient(self)
        self.history = historyClient(self)
        self.homeTheater = homeTheaterClient(self)
        self.households = householdsClient(self)
        self.info = infoClient(self)
        self.management = managementClient(self)
        self.musicServiceAccounts = musicServiceAccountsClient(self)
        self.networkTest = networkTestClient(self)
        self.platformInternal = platformInternalClient(self)
        self.playback = playbackClient(self)
        self.playbackExtended = playbackExtendedClient(self)
        self.playbackMetadata = playbackMetadataClient(self)
        self.playbackSession = playbackSessionClient(self)
        self.playerVolume = playerVolumeClient(self)
        self.playlists = playlistsClient(self)
        self.power = powerClient(self)
        self.recommendation = recommendationClient(self)
        self.roomDetection = roomDetectionClient(self)
        self.settings = settingsClient(self)
        self.soundSwap = soundSwapClient(self)
        self.topology = topologyClient(self)
        self.trueplay = trueplayClient(self)
        self.upnpAVTransport = upnpAVTransportClient(self)
        self.upnpAlarmClock = upnpAlarmClockClient(self)
        self.upnpAudioIn = upnpAudioInClient(self)
        self.upnpContentDirectory = upnpContentDirectoryClient(self)
        self.upnpHTControl = upnpHTControlClient(self)
        self.upnpMusicServices = upnpMusicServicesClient(self)
        self.upnpQueue = upnpQueueClient(self)
        self.upnpRenderingControl = upnpRenderingControlClient(self)
        self.upnpSystemProperties = upnpSystemPropertiesClient(self)
        self.upnpZoneGroupTopology = upnpZoneGroupTopologyClient(self)
        self.voice = voiceClient(self)


# This class was automatically generated and should only be edited via namespace-client.py.template
class alarmsClient(object):
    """
    This internal namespace is used within the player to implement Amazon Alexa
    alarms. There are no public commands, but internal muse events are used to
    connect the Sonos alarm infrastructure with the Alexa SDK.
    """

    def __init__(self, museWebsocketClient):
        self._museConnection = museWebsocketClient


# This class was automatically generated and should only be edited via namespace-client.py.template
class areasClient(object):
    """
    This namespace enables client applications (including the Sonos app) to create, retrieve,
    update, and delete areas (saved groups) on players.

    Starting in version 1.19.1, households include a default "Everywhere" area that contains all
    visible players. This area dynamically derives playerIds from all of the visible players in the
    current household. This area has a static ID (7055133f-81e7-45e6-ba70-8803966c7185) and includes
    an isReadOnly boolean of true to indicate that it is read-only. Commands cannot update or remove 
    read-only areas. For example, you cannot use updateArea or removeArea to change it. All other 
    areas have an isReadOnly value of false.
    """

    def __init__(self, museWebsocketClient):
        self._museConnection = museWebsocketClient

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def subscribe(self, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use this command to subscribe to events in the areas namespace.

        This method was autogenerated from the areas namespace xml definition
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return:
        """

        header = {
            "namespace": "areas",
            "command": "subscribe",
            "householdId": self._museConnection.hhid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def unsubscribe(self, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use this command to unsubscribe to events in the areas namespace.

        This method was autogenerated from the areas namespace xml definition
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return:
        """

        header = {
            "namespace": "areas",
            "command": "unsubscribe",
            "householdId": self._museConnection.hhid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def getAreas(self, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use the getAreas command to get a list of all areas in a household. As of version 1.19.1, this 
        returns an "Everywhere" area that contains all visible players.

        This method was autogenerated from the areas namespace xml definition
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: areasEvent
        """

        header = {
            "namespace": "areas",
            "command": "getAreas",
            "householdId": self._museConnection.hhid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def createArea(self, name=None, playerIds=None, oauthToken=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use the createArea command to create a new area using a list of player IDs.

        This method was autogenerated from the areas namespace xml definition
        :param name: (Required)
        :param playerIds: (Required)
        :param oauthToken: (Required) HH_CONFIG_ADMIN scoped oauth token
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: areaEvent playerSetErrorEvent globalErrorEvent
        """

        header = {
            "namespace": "areas",
            "command": "createArea",
            "householdId": self._museConnection.hhid
        }

        oauthToken = self._museConnection.hhConfigAdminToken if oauthToken is None else oauthToken
        # Verified required oauthToken param is not None
        assert oauthToken is not None, "Command requires an oauthToken param"
        header["authorization"] = "bearer {}".format(oauthToken)
        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if name is None:
                missing_list.append('name')
            if playerIds is None:
                missing_list.append('playerIds')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'name': name,
            'playerIds': playerIds,
        }

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def updateArea(self, areaId=None, oauthToken=None, name=None, playerIds=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use the updateArea command to update the contents of an existing area. ERROR_AREAS_READ_ONLY 
        returns if the area is read-only.

        This method was autogenerated from the areas namespace xml definition
        :param areaId: (Required)
        :param name: (Optional)
        :param playerIds: (Optional)
        :param oauthToken: (Required) HH_CONFIG_ADMIN scoped oauth token
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: areaEvent playerSetErrorEvent globalErrorEvent
        """

        header = {
            "namespace": "areas",
            "command": "updateArea",
            "householdId": self._museConnection.hhid
        }

        oauthToken = self._museConnection.hhConfigAdminToken if oauthToken is None else oauthToken
        # Verified required oauthToken param is not None
        assert oauthToken is not None, "Command requires an oauthToken param"
        header["authorization"] = "bearer {}".format(oauthToken)
        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if areaId is None:
                missing_list.append('areaId')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'areaId': areaId,
        }

        # Only send optional parameters if they have a value
        if name is not None:
            body["name"] = name
        if playerIds is not None:
            body["playerIds"] = playerIds

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def removeArea(self, areaId=None, oauthToken=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use the removeArea command to remove an existing area. ERROR_AREAS_READ_ONLY returns if the area 
        is read-only.

        This method was autogenerated from the areas namespace xml definition
        :param areaId: (Required)
        :param oauthToken: (Required) HH_CONFIG_ADMIN scoped oauth token
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: areasEvent globalErrorEvent
        """

        header = {
            "namespace": "areas",
            "command": "removeArea",
            "householdId": self._museConnection.hhid
        }

        oauthToken = self._museConnection.hhConfigAdminToken if oauthToken is None else oauthToken
        # Verified required oauthToken param is not None
        assert oauthToken is not None, "Command requires an oauthToken param"
        header["authorization"] = "bearer {}".format(oauthToken)
        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if areaId is None:
                missing_list.append('areaId')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'areaId': areaId,
        }

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]


# This class was automatically generated and should only be edited via namespace-client.py.template
class audioClipClient(object):
    """
    The audioClip namespace enables your app or hardware integration to play short audio clips on Sonos. Youll have the option of specifying a custom URL or using a Sonos provided sound. The clip may be mixed with any playing content. Not all devices can implement the commands in this namespace. Devices that support the commands include the AUDIO_CLIP capability in the player object (see the group object for details).

    Commands in this namespace are player targeted, by default.
    """

    def __init__(self, museWebsocketClient):
        self._museConnection = museWebsocketClient

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def subscribe(self, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use this command to subscribe to events in the audioClip namespace.

        This method was autogenerated from the audioClip namespace xml definition
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: globalErrorEvent
        """

        header = {
            "namespace": "audioClip",
            "command": "subscribe",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def unsubscribe(self, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use this command to unsubscribe to events in the audioClip namespace.

        This method was autogenerated from the audioClip namespace xml definition
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: globalErrorEvent
        """

        header = {
            "namespace": "audioClip",
            "command": "unsubscribe",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def loadAudioClip(self, name=None, appId=None, priority=None, clipType=None, streamUrl=None, httpAuthorization=None, volume=None, clipBehavior=None, clipMetadata=None, volumeRampDownSeconds=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use the loadAudioClip command in the audioClip namespace to schedule an audio clip for playback. The command returns immediately, indicating whether the audio clip was successfully scheduled or not.

        The player can handle multiple audio clips and implements a simple priority system to determine playback order:

          A High priority audio clip can interrupt another high priority audio clip if the latter has played for more then 10 seconds.
          A high priority audio clip can interrupt a low priority audio clip at any time.
          A low priority audio clip can interrupt a low priority audio clip at any time.

        This method was autogenerated from the audioClip namespace xml definition
        :param name: (Required) User identifiable string.
        :param appId: (Required) This string identifies the app that created the audioClip. Companies should use their reversed Internet domain name as the identifier, similar to com.acme.app.
        :param priority: (Optional) Priority rules: LOW cannot interrupt HIGH, all other interruptions allowed
        :param clipType: (Optional) (Optional) Sonos plays a built-in sound when you send this parameter. The default value is CHIME.
        :param streamUrl: (Optional) (Optional) Sonos will play this URL when you provide one. The caller does not need to specify a CUSTOM clipType in addition to providing the streamUrl. Sonos supports only MP3 or WAV files as audio clips.
        :param httpAuthorization: (Optional) (Optional) Set a string to pass in the Authorization header when fetching the streamUrl. Omit this parameter to omit the Authorization header. Sonos includes the Authorization header when the streamUrl is secure (HTTPS). Sonos supports an httpAuthorization value up to 512 bytes.
        :param volume: (Optional) (Optional) Audio Clip playback volume, between 0 and 100. There are internal upper and lower limits for the audio clip volume level in order to prevent the audio clip from being too loud or inaudible. If the parameter is beyond those limits, Sonos automatically adjusts the audio clip volume to the lower or upper limit. The default behavior is to playback at the current player volume.
        :param clipBehavior: (Optional) Provides options for:
            1. Mixing with or pausing currently playing audio
            2. Playing on the targeted player or a bonded set of players
        :param clipMetadata: (Optional) Provide metadata to be displayed in the now-playing field while the clip is playing.
            Custom metadata will not be displayed if the clip is mixed with currently playing audio.
        :param volumeRampDownSeconds: (Optional) Ramp down the volume of the currently playing audio over this number of seconds before
            playing the audio clip. If nothing is playing, the clip will begin immediately. If
            the current audio finishes before volumeRampDown seconds have passed, the clip will
            begin playing.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: audioClipEvent globalErrorEvent
        """

        header = {
            "namespace": "audioClip",
            "command": "loadAudioClip",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if name is None:
                missing_list.append('name')
            if appId is None:
                missing_list.append('appId')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'name': name,
            'appId': appId,
        }

        # Only send optional parameters if they have a value
        if priority is not None:
            body["priority"] = priority
        if clipType is not None:
            body["clipType"] = clipType
        if streamUrl is not None:
            body["streamUrl"] = streamUrl
        if httpAuthorization is not None:
            body["httpAuthorization"] = httpAuthorization
        if volume is not None:
            body["volume"] = volume
        if clipBehavior is not None:
            body["clipBehavior"] = clipBehavior
        if clipMetadata is not None:
            body["clipMetadata"] = clipMetadata
        if volumeRampDownSeconds is not None:
            body["volumeRampDownSeconds"] = volumeRampDownSeconds

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def cancelAudioClip(self, id=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use the cancelAudioClip command in the audioClip namespace to cancel a specific audio clip from playing. Sonos sends an error if it has already finished playing the selected audio clip.

        This method was autogenerated from the audioClip namespace xml definition
        :param id: (Required) The identifier of the audio clip from the playAudioClip response.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: globalErrorEvent
        """

        header = {
            "namespace": "audioClip",
            "command": "cancelAudioClip",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if id is None:
                missing_list.append('id')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'id': id,
        }

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]


# This class was automatically generated and should only be edited via namespace-client.py.template
class authorizationClient(object):
    """
    A new system that can manage on-the-fly access to Sonos systems. The authorization service grants permission
    for a user to perform actions on a given system, given a token.
    """

    def __init__(self, museWebsocketClient):
        self._museConnection = museWebsocketClient

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def resolveToken(self, token=None, objectId=None, objectType=None, attributes=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        This request is used to validate tokens. The service accepts an opaque token and provides
            a status, user information, and links to an associated policy.

        This method was autogenerated from the authorization namespace xml definition
        :param token: (Optional)
        :param objectId: (Optional)
        :param objectType: (Optional)
        :param attributes: (Optional)
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: No event
        """

        header = {
            "namespace": "authorization",
            "command": "resolveToken",

        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        # Only send optional parameters if they have a value
        if token is not None:
            body["token"] = token
        if objectId is not None:
            body["objectId"] = objectId
        if objectType is not None:
            body["objectType"] = objectType
        if attributes is not None:
            body["attributes"] = attributes

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def getPolicyKey(self, policyKey=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Once the policy key is determined by either cache lookup or cloud request, the policy must be resolved into a set of permissions.

        This method was autogenerated from the authorization namespace xml definition
        :param policyKey: (Optional) This is the policy key returned from deviceResolve.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: No event
        """

        header = {
            "namespace": "authorization",
            "command": "getPolicyKey",

        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        # Only send optional parameters if they have a value
        if policyKey is not None:
            body["policyKey"] = policyKey

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]


# This class was automatically generated and should only be edited via namespace-client.py.template
class clientStatusClient(object):
    """
    This namespace allows Muse-in-the-Cloud ("MitC") clients to query the status of their cloud clients.

    MitC clients are identified via an API Key, which is provided by the client in every HTTP request
    or when opening a websocket connection to MitC.
    """

    def __init__(self, museWebsocketClient):
        self._museConnection = museWebsocketClient

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def getStatus(self, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Requests information on the current status of a MitC client, which is identified through an API key provided by the wire protocol (HTTP or websockets).

        This method was autogenerated from the clientStatus namespace xml definition
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: clientStatusEvent
        """

        header = {
            "namespace": "clientStatus",
            "command": "getStatus",

        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def activate(self, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Activates an inactive client or refreshes a currently active one to reload any registered client information changes. Typically called from a Sonos portal when changes are made or when a client needs to re-activate callbacks through MitC.

        This method was autogenerated from the clientStatus namespace xml definition
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: clientStatusEvent
        """

        header = {
            "namespace": "clientStatus",
            "command": "activate",

        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def deactivate(self, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Deactivates an active or temporarily inactive client. Typically called from a Sonos portal when changes are made or when a client needs to deactivate callbacks through MitC, or the client is removed from the portal.

        This method was autogenerated from the clientStatus namespace xml definition
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: clientStatusEvent
        """

        header = {
            "namespace": "clientStatus",
            "command": "deactivate",

        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]


# This class was automatically generated and should only be edited via namespace-client.py.template
class devicesClient(object):
    """
    The devices namespace enables you to retrieve information about cloud devices
    in a household.
    """

    def __init__(self, museWebsocketClient):
        self._museConnection = museWebsocketClient

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def getDevices(self, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use the getDevices command in the devices namespace to get information
        about any device that is/has connected to the cloud in a given household.

        This method was autogenerated from the devices namespace xml definition
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: devicesEvent
        """

        header = {
            "namespace": "devices",
            "command": "getDevices",
            "householdId": self._museConnection.hhid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]


# This class was automatically generated and should only be edited via namespace-client.py.template
class diagnosticsClient(object):
    """
    This namespace enables client applications to initiate diagnostics related operations on the player.
    """

    def __init__(self, museWebsocketClient):
        self._museConnection = museWebsocketClient

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def subscribe(self, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use this command to subscribe to events in the diagnostics namespace.

        This method was autogenerated from the diagnostics namespace xml definition
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return:
        """

        header = {
            "namespace": "diagnostics",
            "command": "subscribe",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def unsubscribe(self, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use this command to unsubscribe to events in the diagnostics namespace.

        This method was autogenerated from the diagnostics namespace xml definition
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return:
        """

        header = {
            "namespace": "diagnostics",
            "command": "unsubscribe",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def submitDiagnostics(self, includeControllers=None, type=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use the submitDiagnostics command to initiate a diagnostic submission. The command will queue
        a diagnostic submission attempt and return a submissionId identifying the attempt.
        Once the diagnostic submission attempt successfully finishes (which may take significant time),
        Sonos sends a diagnosticSubmission event, including the final diagnostic ID, to clients. If
        diagnostic submission fails, the player generates a diagnosticSubmission event
        "status" = DIAGNOSTIC_SUBMISSION_FAILED.

        This method was autogenerated from the diagnostics namespace xml definition
        :param includeControllers: (Optional) Boolean indicating whether controller information should be included in the submitted diagnostic.
        :param type: (Optional) Describes the origin of this diagnostic.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: diagnosticInfoEvent globalErrorEvent
        """

        header = {
            "namespace": "diagnostics",
            "command": "submitDiagnostics",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        # Only send optional parameters if they have a value
        if includeControllers is not None:
            body["includeControllers"] = includeControllers
        if type is not None:
            body["type"] = type

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def getMetadata(self, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use the getMetadata command to get the diagnostic metadata of the current diagnostic submission.
        Returns ERROR_NO_CONTENT if there is no submission currently active.

        This method was autogenerated from the diagnostics namespace xml definition
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: diagnosticSubmissionMetadataEvent globalErrorEvent
        """

        header = {
            "namespace": "diagnostics",
            "command": "getMetadata",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]


# This class was automatically generated and should only be edited via namespace-client.py.template
class entitlementsClient(object):
    """
    The entitlements namespace retrieves and stores entitlements attached to the customer id associated with the household.
    """

    def __init__(self, museWebsocketClient):
        self._museConnection = museWebsocketClient

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def subscribe(self, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use this command to subscribe to events in the entitlements namespace.

        This method was autogenerated from the entitlements namespace xml definition
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: No event
        """

        header = {
            "namespace": "entitlements",
            "command": "subscribe",
            "householdId": self._museConnection.hhid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def unsubscribe(self, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use this command to unsubscribe to events in the entitlements namespace.

        This method was autogenerated from the entitlements namespace xml definition
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: No event
        """

        header = {
            "namespace": "entitlements",
            "command": "unsubscribe",
            "householdId": self._museConnection.hhid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def getEntitlements(self, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Fetches a list of entitlements granted to the Sonos customer id/household id associated with the system.

        This method was autogenerated from the entitlements namespace xml definition
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: entitlementsListEvent globalErrorEvent
        """

        header = {
            "namespace": "entitlements",
            "command": "getEntitlements",
            "householdId": self._museConnection.hhid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]


# This class was automatically generated and should only be edited via namespace-client.py.template
class favoritesClient(object):
    """
    This namespace exposes the user favorites that are seen in the Sonos controller.
    """

    def __init__(self, museWebsocketClient):
        self._museConnection = museWebsocketClient

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def subscribe(self, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use this command to subscribe to events in the favorites namespace.

        When subscribed, Sonos sends asynchronous versionChanged events when users update their Sonos favorites. Your app can then choose to fetch the favorites as needed whenever the version changes. This is because the FavoritesList object can be large for asynchronous events.

        This method was autogenerated from the favorites namespace xml definition
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return:
        """

        header = {
            "namespace": "favorites",
            "command": "subscribe",
            "householdId": self._museConnection.hhid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def unsubscribe(self, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use this command to unsubscribe to events in the favorites namespace.

        This method was autogenerated from the favorites namespace xml definition
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return:
        """

        header = {
            "namespace": "favorites",
            "command": "unsubscribe",
            "householdId": self._museConnection.hhid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def getFavorites(self, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use the getFavorites command in the favorites namespace to get the list of Sonos favorites for a household. Favorites do not include pinned items (any non-playable containers pinned to My Sonos) or Sonos playlists. See the Save your favorites section in the Sonos user guide and Add favorites for details. The player limits the number of Sonos favorites to 70.
        An array of objects is returned such that a developer can implement the favorites picker from the Sonos controller.

        This method was autogenerated from the favorites namespace xml definition
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: favoritesListEvent globalErrorEvent
        """

        header = {
            "namespace": "favorites",
            "command": "getFavorites",
            "householdId": self._museConnection.hhid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def loadFavorite(self, favoriteId=None, action=None, playModes=None, playOnCompletion=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        The loadFavorite command in the favorites namespace activates a favorite within the default playback session. This command interrupts any active private playback sessions. Sonos adds album, tracklist, and track favorites to the queue and activates the queue. This prevents your app from overwriting user-curated queues.

        This method was autogenerated from the favorites namespace xml definition
        :param favoriteId: (Required) The identifier of the favorite. You can find this in the favoriteList object in the getFavorites response.
        :param action: (Optional) (Optional) Controls how the the player inserts the favorite into the shared queue, such as APPEND, INSERT, INSERT_NEXT, or REPLACE. Not used when the favorite is a radio station (programmed or streamed). If omitted, defaults to append.
        :param playModes: (Optional) (Optional) Defines the functionality of one or more play modes. You can set these to customize shuffle, repeat, repeat-one and crossfade. The player ignores this parameter when the loaded favorite does not allow custom play modes, such as for streaming radio stations.
        :param playOnCompletion: (Optional) (Optional) If true, the player automatically starts playback. If false or not provided, the player remains in the PLAYBACK_IDLE state.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: groupCoordinatorChangedEvent globalErrorEvent
        """

        header = {
            "namespace": "favorites",
            "command": "loadFavorite",
            "groupId": self._museConnection.getGroupId()
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if favoriteId is None:
                missing_list.append('favoriteId')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'favoriteId': favoriteId,
        }

        # Only send optional parameters if they have a value
        if action is not None:
            body["action"] = action
        if playModes is not None:
            body["playModes"] = playModes
        if playOnCompletion is not None:
            body["playOnCompletion"] = playOnCompletion

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]


# This class was automatically generated and should only be edited via namespace-client.py.template
class globalClient(object):
    """
    This is the global namespace.
    """

    def __init__(self, museWebsocketClient):
        self._museConnection = museWebsocketClient


# This class was automatically generated and should only be edited via namespace-client.py.template
class groupVolumeClient(object):
    """
    The groupVolume namespace includes commands and events that enable your app to control and update group volume and group mute state.
    """

    def __init__(self, museWebsocketClient):
        self._museConnection = museWebsocketClient

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def subscribe(self, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use this command to subscribe to events in the groupVolume namespace.

        This method was autogenerated from the groupVolume namespace xml definition
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: groupCoordinatorChangedEvent
        """

        header = {
            "namespace": "groupVolume",
            "command": "subscribe",
            "groupId": self._museConnection.getGroupId()
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def unsubscribe(self, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use this command to unsubscribe to events in the groupVolume namespace.

        This method was autogenerated from the groupVolume namespace xml definition
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: groupCoordinatorChangedEvent
        """

        header = {
            "namespace": "groupVolume",
            "command": "unsubscribe",
            "groupId": self._museConnection.getGroupId()
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def setVolume(self, volume=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use the setVolume command in the groupVolume namespace to set group volume to a specific level and unmute the group if muted.

        When your app sets the group volume, the group coordinator calculates the required changes to the volume level for each player in the group so that the result is the average volume level of the group as a whole. The group coordinator then adjusts its local volume and initiates network transactions with the other players in the group to adjust their volumes accordingly. While players adjust their volumes, the group coordinator may generate one or more groupVolume events.

        Since this command can generate additional network transactions and events, your app should optimize how often it is invoked to maintain a good user experience without flooding the network, such as when implementing a touch screen volume slider that controls a group of five players.

        This method was autogenerated from the groupVolume namespace xml definition
        :param volume: (Required) The new group volume as an integer between 0 and 100, inclusive. If your app submits a number outside of this range, you will receive an ERROR_INVALID_PARAMETER error.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: groupCoordinatorChangedEvent globalErrorEvent
        """

        header = {
            "namespace": "groupVolume",
            "command": "setVolume",
            "groupId": self._museConnection.getGroupId()
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if volume is None:
                missing_list.append('volume')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'volume': volume,
        }

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def setRelativeVolume(self, volumeDelta=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use the setRelativeVolume command in the groupVolume namespace to increase or decrease group volume, and unmute the group if muted.

        Your app can use setRelativeVolume instead of setVolume when the user intent is to increase or decrease the group volume, but not to set the final volume to a particular value. For example, your app should use setRelativeVolume when the user presses hard volume plus/minus buttons on a mobile device.

        The group will automatically limit the final volume set within the valid range, so your app does not need to worry about that.

        See setVolume for more details on how group volume works.

        This method was autogenerated from the groupVolume namespace xml definition
        :param volumeDelta: (Required) An integer between -100 and 100 (including those values) indicating the amount to increase or decrease the current group volume. The group coordinator adds this value to the current group volume and then keeps the result in the range of 0 to 100.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: groupCoordinatorChangedEvent globalErrorEvent
        """

        header = {
            "namespace": "groupVolume",
            "command": "setRelativeVolume",
            "groupId": self._museConnection.getGroupId()
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if volumeDelta is None:
                missing_list.append('volumeDelta')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'volumeDelta': volumeDelta,
        }

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def setMute(self, muted=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use the setMute command in the groupVolume namespace to mute and unmute the group.

        The groups mute state is independent of its group volume. For example a groups mute state can be true although its group volume is still 20, and the user will not hear any audio coming from the group of players. Individual player volume values are stored by each player in the group while muted, which allows the group to retain the relative volume of players in the group. That is important information to preserve, since users may have carefully configured the individual player volumes in the group with a Sonos controller. Your app should not mute the group by calling setVolume with zero volume, otherwise the relative volume of players in the group will be lost.

        If some players in the group are muted and others are not, calling setMute to mute the group will mute all the players in the group. The individual players mute state prior to calling setMute is not preserved.

        To get the current groups mute state, use the getVolume command or subscribe to the groupVolume event.

        This method was autogenerated from the groupVolume namespace xml definition
        :param muted: (Required) The desired mute state of the group: true for muted and false for not muted.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: groupCoordinatorChangedEvent globalErrorEvent
        """

        header = {
            "namespace": "groupVolume",
            "command": "setMute",
            "groupId": self._museConnection.getGroupId()
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if muted is None:
                missing_list.append('muted')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'muted': muted,
        }

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def getVolume(self, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use the getVolume command in the groupVolume namespace to get the volume and mute state of a group.

        This method was autogenerated from the groupVolume namespace xml definition
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: groupVolumeEvent groupCoordinatorChangedEvent globalErrorEvent
        """

        header = {
            "namespace": "groupVolume",
            "command": "getVolume",
            "groupId": self._museConnection.getGroupId()
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]


# This class was automatically generated and should only be edited via namespace-client.py.template
class groupsClient(object):
    """
    The groups namespace enables your app or hardware integration to retrieve information about 
    how players are grouped in a household and to create or modify groups.

    When creating or modifying groups, the group info response only includes the list of players 
    in the final group. It doesnt include a flag to show whether the changes match the original 
    desired group or not. This could lead to partial successes.

    Additionally, this command may trigger significant player-to-player communication over the 
    LAN. In some cases, you may not receive a response.

    As a best practice, check the final set of players returned by the command, either in the 
    group info response, or by getting a list of players in the group.
    """

    def __init__(self, museWebsocketClient):
        self._museConnection = museWebsocketClient

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def subscribe(self, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use this command to subscribe to events in the groups namespace.

        This method was autogenerated from the groups namespace xml definition
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return:
        """

        header = {
            "namespace": "groups",
            "command": "subscribe",
            "householdId": self._museConnection.hhid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def unsubscribe(self, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use this command to unsubscribe to events in the groups namespace.

        This method was autogenerated from the groups namespace xml definition
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return:
        """

        header = {
            "namespace": "groups",
            "command": "unsubscribe",
            "householdId": self._museConnection.hhid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def getGroups(self, includeDeviceInfo=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use the getGroups command in the groups namespace to get information about groups
        and players in a household.

        This method was autogenerated from the groups namespace xml definition
        :param includeDeviceInfo: (Optional) The response will include the deviceInfo for each player object when this
            argument is present and true.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: groupsEvent globalErrorEvent
        """

        header = {
            "namespace": "groups",
            "command": "getGroups",
            "householdId": self._museConnection.hhid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        # Only send optional parameters if they have a value
        if includeDeviceInfo is not None:
            body["includeDeviceInfo"] = includeDeviceInfo

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def getGroupsEx(self, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        This is a version of the getGroups command that sets includeDeviceInfo=true until
        we implement SWPBL-107560. This allows cloud clients to request the extra data.

        This method was autogenerated from the groups namespace xml definition
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: groupsEvent globalErrorEvent
        """

        header = {
            "namespace": "groups",
            "command": "getGroupsEx",
            "householdId": self._museConnection.hhid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def createGroup(self, playerIds=None, musicContextGroupId=None, areaIds=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use the createGroup command in the groups namespace to create a new group from a list
        of players. The player returns a group object with the group ID. This may be an existing
        group ID if an existing group is a subset of the new group. In this case, Sonos may
        build the new group by adding new players to the existing group.

        This method was autogenerated from the groups namespace xml definition
        :param playerIds: (Required) An array of player ID strings to group.
        :param musicContextGroupId: (Optional) (Optional) The group containing the audio that you want to use. If empty or not provided, 
            the new group will not contain any audio.
        :param areaIds: (Optional) (Optional) List of source areaIds in the group. Emitted in groupInfo events. As of version 
            1.19.1, this can include the "Everywhere" area ID. If it does, this indicates that the group 
            includes all visible players.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: groupInfoEvent playerSetErrorEvent globalErrorEvent
        """

        header = {
            "namespace": "groups",
            "command": "createGroup",
            "householdId": self._museConnection.hhid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if playerIds is None:
                missing_list.append('playerIds')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'playerIds': playerIds,
        }

        # Only send optional parameters if they have a value
        if musicContextGroupId is not None:
            body["musicContextGroupId"] = musicContextGroupId
        if areaIds is not None:
            body["areaIds"] = areaIds

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def modifyGroupMembers(self, playerIdsToAdd=None, playerIdsToRemove=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use the modifyGroupMembers command in the groups namespace to add players to and remove
        players from a group. In response to this command, Sonos first adds players to the group,
        then removes players from the group.

        This method was autogenerated from the groups namespace xml definition
        :param playerIdsToAdd: (Required) An array of player ID strings of players to add to the group.
        :param playerIdsToRemove: (Required) An array of player ID strings of players to remove from the group.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: groupInfoEvent playerSetErrorEvent globalErrorEvent
        """

        header = {
            "namespace": "groups",
            "command": "modifyGroupMembers",
            "groupId": self._museConnection.getGroupId()
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if playerIdsToAdd is None:
                missing_list.append('playerIdsToAdd')
            if playerIdsToRemove is None:
                missing_list.append('playerIdsToRemove')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'playerIdsToAdd': playerIdsToAdd,
            'playerIdsToRemove': playerIdsToRemove,
        }

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def setGroupMembers(self, playerIds=None, areaIds=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use the setGroupMembers command in the groups namespace to replace the players in an
        existing group with a new set.

        This method was autogenerated from the groups namespace xml definition
        :param playerIds: (Required) An array of player ID strings corresponding to the new set of players for the group.
        :param areaIds: (Optional) (Optional) List of source areaIds in the group. Emitted in groupInfo events. As of 
            version 1.19.1, this can include the "Everywhere" area ID. If it does, this indicates 
            that the group includes all visible players.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: groupInfoEvent playerSetErrorEvent globalErrorEvent
        """

        header = {
            "namespace": "groups",
            "command": "setGroupMembers",
            "groupId": self._museConnection.getGroupId()
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if playerIds is None:
                missing_list.append('playerIds')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'playerIds': playerIds,
        }

        # Only send optional parameters if they have a value
        if areaIds is not None:
            body["areaIds"] = areaIds

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]


# This class was automatically generated and should only be edited via namespace-client.py.template
class hardwareStatusClient(object):
    """
    The hardwareStatus namespace allows clients to query and configure hardware components such as the battery.
    """

    def __init__(self, museWebsocketClient):
        self._museConnection = museWebsocketClient

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def getWirelessStatus(self, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Gets the status of wireless network interface.

        This method was autogenerated from the hardwareStatus namespace xml definition
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: wirelessNetworkEvent
        """

        header = {
            "namespace": "hardwareStatus",
            "command": "getWirelessStatus",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def getBluetoothStatus(self, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Gets the status of Bluetooth interface.

        This method was autogenerated from the hardwareStatus namespace xml definition
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: bluetoothEvent globalErrorEvent
        """

        header = {
            "namespace": "hardwareStatus",
            "command": "getBluetoothStatus",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def getBatteryStatus(self, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Gets the status of the battery.

        This method was autogenerated from the hardwareStatus namespace xml definition
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: batteryEvent globalErrorEvent
        """

        header = {
            "namespace": "hardwareStatus",
            "command": "getBatteryStatus",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def changeBatteryStatus(self, oauthToken=None, rawBatteryPercentage=None, batteryPercentage=None, chargingState=None, batteryTemperature=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Change the charging status

        This method was autogenerated from the hardwareStatus namespace xml definition
        :param rawBatteryPercentage: (Optional)
        :param batteryPercentage: (Optional) A mapping of rawBatteryPercentage, where the critical percentage of rawBatteryPercentage is mapped to 0% batteryPercentage
        :param chargingState: (Optional)
        :param batteryTemperature: (Optional)
        :param oauthToken: (Required) HH_CONFIG_ADMIN scoped oauth token
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: batteryEvent
        """

        header = {
            "namespace": "hardwareStatus",
            "command": "changeBatteryStatus",
            "playerId": self._museConnection.uuid
        }

        oauthToken = self._museConnection.hhConfigAdminToken if oauthToken is None else oauthToken
        # Verified required oauthToken param is not None
        assert oauthToken is not None, "Command requires an oauthToken param"
        header["authorization"] = "bearer {}".format(oauthToken)
        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        # Only send optional parameters if they have a value
        if rawBatteryPercentage is not None:
            body["rawBatteryPercentage"] = rawBatteryPercentage
        if batteryPercentage is not None:
            body["batteryPercentage"] = batteryPercentage
        if chargingState is not None:
            body["chargingState"] = chargingState
        if batteryTemperature is not None:
            body["batteryTemperature"] = batteryTemperature

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def getBatteryCells(self, oauthToken=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Gets the status of the raw battery cells.

        This method was autogenerated from the hardwareStatus namespace xml definition
        :param oauthToken: (Required) HH_CONFIG scoped oauth token
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: batteryCellsEvent globalErrorEvent
        """

        header = {
            "namespace": "hardwareStatus",
            "command": "getBatteryCells",
            "playerId": self._museConnection.uuid
        }

        oauthToken = self._museConnection.hhConfigToken if oauthToken is None else oauthToken
        # Verified required oauthToken param is not None
        assert oauthToken is not None, "Command requires an oauthToken param"
        header["authorization"] = "bearer {}".format(oauthToken)
        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def transitionToShipMode(self, oauthToken=None, requiredMinimumBatteryPercentage=None, requiredMaximumBatteryPercentage=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        [Sonos private internal command]
        This command can be used to transition the device into shipmode.
        Requirements:
        1. Device must be Factory Reset
        2. Device has a functional battery connection
        3. Device must be connected to an acceptable charging power source
        WARNING:
        Once the device is in ship mode it will immediately hard crash if removed from the power source (NOT recommended).
        Instead the device needs to be shutdown in an orderly manner.
        Consider using the hardwareStatus.initiateOrderlyShutdown command

        This method was autogenerated from the hardwareStatus namespace xml definition
        :param requiredMinimumBatteryPercentage: (Optional) The transition to ship mode will not be allowed if the actual battery level percentage is less than this requirement.
        :param requiredMaximumBatteryPercentage: (Optional) The transition to ship mode will not be allowed if the actual battery level percentage is greater than this requirement.
        :param oauthToken: (Required) HH_CONFIG_ADMIN scoped oauth token
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: transitionToShipModeStatusEvent globalErrorEvent
        """

        header = {
            "namespace": "hardwareStatus",
            "command": "transitionToShipMode",
            "playerId": self._museConnection.uuid
        }

        oauthToken = self._museConnection.hhConfigAdminToken if oauthToken is None else oauthToken
        # Verified required oauthToken param is not None
        assert oauthToken is not None, "Command requires an oauthToken param"
        header["authorization"] = "bearer {}".format(oauthToken)
        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        # Only send optional parameters if they have a value
        if requiredMinimumBatteryPercentage is not None:
            body["requiredMinimumBatteryPercentage"] = requiredMinimumBatteryPercentage
        if requiredMaximumBatteryPercentage is not None:
            body["requiredMaximumBatteryPercentage"] = requiredMaximumBatteryPercentage

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def initiateOrderlyShutdown(self, oauthToken=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        [Sonos private internal command]
        This command can be used to initiate an orderly shutdown on a device which will eventually result in the device powering off.
        Requirement: Device must be Factory Reset
        WARNING:
        The orderly shutdown (and power off) takes a while to complete - usually 2 to 10 seconds.
        Thus in all reasonable situations the response will be received by the caller well BEFORE this operation actually completes.
        Consider using ping + 3 second "safty margin" sleep or other similar polling strategy before assuming that the device as completely finished shutting down.

        This method was autogenerated from the hardwareStatus namespace xml definition
        :param oauthToken: (Required) HH_CONFIG_ADMIN scoped oauth token
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: globalErrorEvent
        """

        header = {
            "namespace": "hardwareStatus",
            "command": "initiateOrderlyShutdown",
            "playerId": self._museConnection.uuid
        }

        oauthToken = self._museConnection.hhConfigAdminToken if oauthToken is None else oauthToken
        # Verified required oauthToken param is not None
        assert oauthToken is not None, "Command requires an oauthToken param"
        header["authorization"] = "bearer {}".format(oauthToken)
        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def getEthernetStatus(self, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Get the status of the Ethernet ports on the device, including port number, status (up/down), speed,
        and full/half duplex.

        This method was autogenerated from the hardwareStatus namespace xml definition
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: ethernetPortsEvent globalErrorEvent
        """

        header = {
            "namespace": "hardwareStatus",
            "command": "getEthernetStatus",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def getWiredSubStatus(self, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Gets the status of the wired sub.

        This method was autogenerated from the hardwareStatus namespace xml definition
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: wiredSubStatusEvent globalErrorEvent
        """

        header = {
            "namespace": "hardwareStatus",
            "command": "getWiredSubStatus",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def getWirelessNetworkStatus(self, oauthToken=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Describes the current wireless network being used by the device.

        This method was autogenerated from the hardwareStatus namespace xml definition
        :param oauthToken: (Required) HH_CONFIG scoped oauth token
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: wirelessNetworkStatusEvent
        """

        header = {
            "namespace": "hardwareStatus",
            "command": "getWirelessNetworkStatus",
            "playerId": self._museConnection.uuid
        }

        oauthToken = self._museConnection.hhConfigToken if oauthToken is None else oauthToken
        # Verified required oauthToken param is not None
        assert oauthToken is not None, "Command requires an oauthToken param"
        header["authorization"] = "bearer {}".format(oauthToken)
        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def activatePairedBluetoothDevice(self, bluetoothAddress=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Sets the active Bluetooth device from the list of paired devices that Bluetooth-supporting Players maintain. Players can be paired with multiple Bluetooth sources over time, and those sources
        will be saved until they are removed via the /pairedBluetoothDevice/remove command. If the supplied bluetoothAddress does not match a paired device, the command will fail.

        This method was autogenerated from the hardwareStatus namespace xml definition
        :param bluetoothAddress: (Optional) The physical address of the Bluetooth device.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return:
        """

        header = {
            "namespace": "hardwareStatus",
            "command": "activatePairedBluetoothDevice",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        # Only send optional parameters if they have a value
        if bluetoothAddress is not None:
            body["bluetoothAddress"] = bluetoothAddress

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def removePairedBluetoothDevice(self, bluetoothAddress=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Removes the specified bluetoothAddress from the list of paired devices that a BT-capable player maintains. Once removed, the device will no longer be able to be activated as a source with the
        /pairedBluetoothDevice/activate command, until it has been paired again.

        This method was autogenerated from the hardwareStatus namespace xml definition
        :param bluetoothAddress: (Optional) The physical address of the Bluetooth device.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return:
        """

        header = {
            "namespace": "hardwareStatus",
            "command": "removePairedBluetoothDevice",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        # Only send optional parameters if they have a value
        if bluetoothAddress is not None:
            body["bluetoothAddress"] = bluetoothAddress

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]


# This class was automatically generated and should only be edited via namespace-client.py.template
class historyClient(object):
    """
    The history namespace retrieves and stores recently played entries intended to be utilized and
        displayed by the controller.
    """

    def __init__(self, museWebsocketClient):
        self._museConnection = museWebsocketClient

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def subscribe(self, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use this command to subscribe to events in the history namespace.

        This method was autogenerated from the history namespace xml definition
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: globalErrorEvent
        """

        header = {
            "namespace": "history",
            "command": "subscribe",
            "householdId": self._museConnection.hhid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def unsubscribe(self, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use this command to unsubscribe to events in the history namespace.

        This method was autogenerated from the history namespace xml definition
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: globalErrorEvent
        """

        header = {
            "namespace": "history",
            "command": "unsubscribe",
            "householdId": self._museConnection.hhid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def getHistory(self, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Fetches a list of the 40 most recently listened to containers.

        This method was autogenerated from the history namespace xml definition
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: contentPagedResourcesEvent globalErrorEvent
        """

        header = {
            "namespace": "history",
            "command": "getHistory",
            "householdId": self._museConnection.hhid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def postHistory(self, oauthToken=None, resource=None, group=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Adds a list of the 40 most recently listened to containers.

        This method was autogenerated from the history namespace xml definition
        :param resource: (Optional)
        :param group: (Optional)
        :param oauthToken: (Required) HH_CONFIG scoped oauth token
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: contentPagedResourcesEvent
        """

        header = {
            "namespace": "history",
            "command": "postHistory",
            "householdId": self._museConnection.hhid
        }

        oauthToken = self._museConnection.hhConfigToken if oauthToken is None else oauthToken
        # Verified required oauthToken param is not None
        assert oauthToken is not None, "Command requires an oauthToken param"
        header["authorization"] = "bearer {}".format(oauthToken)
        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        # Only send optional parameters if they have a value
        if resource is not None:
            body["resource"] = resource
        if group is not None:
            body["group"] = group

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def removeHistoryItem(self, id=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        This command allows users to remove an individual entry from the history.

        This method was autogenerated from the history namespace xml definition
        :param id: (Required) An identifier string for the recommendations request, which can be used to record user feedback. This
                        id is an opaque string that should be retrieved from the `getHistory` command.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: globalErrorEvent
        """

        header = {
            "namespace": "history",
            "command": "removeHistoryItem",
            "householdId": self._museConnection.hhid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if id is None:
                missing_list.append('id')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'id': id,
        }

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def clearHistory(self, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        This command allows users to remove all entries from the history.

        This method was autogenerated from the history namespace xml definition
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: globalErrorEvent
        """

        header = {
            "namespace": "history",
            "command": "clearHistory",
            "householdId": self._museConnection.hhid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]


# This class was automatically generated and should only be edited via namespace-client.py.template
class homeTheaterClient(object):
    """
    The homeTheater namespace contains general commands that can be used by clients that
    wish to control home theater specific functionality (start of TV playback, HDMI CEC
    commands, etc.) Commands in this namespace can return global error responses.
    """

    def __init__(self, museWebsocketClient):
        self._museConnection = museWebsocketClient

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def loadHomeTheaterPlayback(self, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use the loadHomeTheaterPlayback command in the homeTheater namespace to signal
        the player to switch to its TV input (optical or HDMI) for playback.

        Note that this command is only applicable for Sonos players that support home
        theater inputs, such as the Playbar, Playbase, and Beam. If your integration
        sends this command to a player that doesnt support it, the player returns a
        globalError with an errorCode of ERROR_UNSUPPORTED_NAMESPACE.

        This method was autogenerated from the homeTheater namespace xml definition
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: globalErrorEvent
        """

        header = {
            "namespace": "homeTheater",
            "command": "loadHomeTheaterPlayback",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def setTvPowerState(self, tvPowerState=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        If the HDMI CEC bus is available, the setTvPowerState command in the homeTheater
        namespace will instruct the home theater capable device to send a CEC TV On
        command on the bus. The CEC specification does not require that the device
        acknowledges commands. Support for this command varies by TV manufacturer. If the
        TV sends a success or failure response to the player, the player provides it to
        your integration. Otherwise, the player returns a generic success response.

        Note that this command is only applicable for Sonos players that support HDMI ARC.
        Currently this is only the Beam. If your integration sends this command to a player
        that doesnt support it, the player returns a globalError with an errorCode of:

        - ERROR_UNSUPPORTED_NAMESPACE for non-home theater speakers, or
        - ERROR_UNSUPPORTED_COMMAND for home theater speakers without CEC HDMI support.

        This method was autogenerated from the homeTheater namespace xml definition
        :param tvPowerState: (Required) The TV Power State control options.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: globalErrorEvent
        """

        header = {
            "namespace": "homeTheater",
            "command": "setTvPowerState",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if tvPowerState is None:
                missing_list.append('tvPowerState')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'tvPowerState': tvPowerState,
        }

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def getOptions(self, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        This command retrieves the current home theater options.

        Deprecated: Home theater settings have been moved to the settings namespace. Use getPlayerSettings instead

        This method was autogenerated from the homeTheater namespace xml definition
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: homeTheaterOptionsEvent globalErrorEvent
        """

        header = {
            "namespace": "homeTheater",
            "command": "getOptions",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def setOptions(self, nightMode=None, enhanceDialog=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        This command is used to customize the home theater experience. The client application
        can send multiple options to the player concurrently. The player will only change the
        values of those options which are present.

        Deprecated: Home theater settings have been moved to the settings namespace. Use setPlayerSettings instead
        with home theater specific settings

        This method was autogenerated from the homeTheater namespace xml definition
        :param nightMode: (Optional) *Night Sound* is most useful when watching TV at low volumes, such as late at night. It will
            make the dialogue more clear, while reducing the intensity of loud sounds.
        :param enhanceDialog: (Optional) *Speech Enhancement* boosts the audio frequencies associated with the human voice. Turning
            this feature on will make dialogue easier to hear, which can be especially useful during
            action movies.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: homeTheaterOptionsEvent globalErrorEvent
        """

        header = {
            "namespace": "homeTheater",
            "command": "setOptions",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        # Only send optional parameters if they have a value
        if nightMode is not None:
            body["nightMode"] = nightMode
        if enhanceDialog is not None:
            body["enhanceDialog"] = enhanceDialog

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]


# This class was automatically generated and should only be edited via namespace-client.py.template
class householdsClient(object):
    """
    Your app may have access to more than one household tied to an authorization token. Send a
        `GET` command to the households namespace endpoint to get a list of household IDs for which
        your app has access.
    """

    def __init__(self, museWebsocketClient):
        self._museConnection = museWebsocketClient

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def getHouseholds(self, connectedOnly=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        The getHouseholds command requests information on the households that can be acted upon,
                based upon the access token used when calling this API. There are no parameters for this command.

                If successful, Sonos responds with an array of household objects.

        This method was autogenerated from the households namespace xml definition
        :param connectedOnly: (Optional) Lookup all the households, connected or disconnected, when set to false.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: householdsEvent
        """

        header = {
            "namespace": "households",
            "command": "getHouseholds",

        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        # Only send optional parameters if they have a value
        if connectedOnly is not None:
            body["connectedOnly"] = connectedOnly

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]


# This class was automatically generated and should only be edited via namespace-client.py.template
class infoClient(object):
    """
    This namespace is used during the discovery process to get more information about
    a device. The "getInfo" command is advertised on the LAN.
    """

    def __init__(self, museWebsocketClient):
        self._museConnection = museWebsocketClient

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def getInfo(self, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        This command returns more information about the targeted device.

        For testing purposes, this command supports a special playerId value on the
        LAN. Clients may substitute the value "local" for the fully expanded playerId.
        This value is not valid via the cloud interface.

        This method was autogenerated from the info namespace xml definition
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: discoveryInfoEvent globalErrorEvent
        """

        header = {
            "namespace": "info",
            "command": "getInfo",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]


# This class was automatically generated and should only be edited via namespace-client.py.template
class managementClient(object):
    """
    [Sonos private internal command]
    This namespace enables the controller to manage a device on the local network.
    """

    def __init__(self, museWebsocketClient):
        self._museConnection = museWebsocketClient

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def factoryReset(self, oauthToken=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        [Sonos private internal command]
        Direct the device to initiate a factory reset.

        This method was autogenerated from the management namespace xml definition
        :param oauthToken: (Required) HH_CONFIG_ADMIN scoped oauth token
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: globalErrorEvent
        """

        header = {
            "namespace": "management",
            "command": "factoryReset",
            "playerId": self._museConnection.uuid
        }

        oauthToken = self._museConnection.hhConfigAdminToken if oauthToken is None else oauthToken
        # Verified required oauthToken param is not None
        assert oauthToken is not None, "Command requires an oauthToken param"
        header["authorization"] = "bearer {}".format(oauthToken)
        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]


# This class was automatically generated and should only be edited via namespace-client.py.template
class musicServiceAccountsClient(object):
    """
    The musicServiceAccounts namespace contains the match command, which your integration can use to match music service user accounts with those stored in the household.
    """

    def __init__(self, museWebsocketClient):
        self._museConnection = museWebsocketClient

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def match(self, userIdHashCode=None, nickname=None, serviceId=None, linkCode=None, linkDeviceId=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use the match command in the musicServiceAccounts namespace to get the account ID of a music service user account from the player.

        All players in the household return the same accounts. Changes made to a player are automatically replicated throughout the household.

        This method was autogenerated from the musicServiceAccounts namespace xml definition
        :param userIdHashCode: (Required) Opaque hash of the user account. You must use the same algorithm used by your SMAPI server. See getDeviceAuthToken and getUserInfo SMAPI requests for details.
        :param nickname: (Required) The name for the music service account presented to the user when they view their account from the Sonos app.
        :param serviceId: (Required) The unique identifier for the music service. Maximum length of 20 characters.
        :param linkCode: (Optional) (Optional) The link code generated for device authentication. Your SMAPI service can also send this to the player in the getAppLink SMAPI request. The player can send it back in the getDeviceAuthToken SMAPI request.
        :param linkDeviceId: (Optional) (Optional) Private data associated with the link code to prevent phishing. Like linkCode, also sent in the getAppLink SMAPI request and returned in the getDeviceAuthToken SMAPI request.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: musicServiceAccountEvent globalErrorEvent
        """

        header = {
            "namespace": "musicServiceAccounts",
            "command": "match",
            "householdId": self._museConnection.hhid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if userIdHashCode is None:
                missing_list.append('userIdHashCode')
            if nickname is None:
                missing_list.append('nickname')
            if serviceId is None:
                missing_list.append('serviceId')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'userIdHashCode': userIdHashCode,
            'nickname': nickname,
            'serviceId': serviceId,
        }

        # Only send optional parameters if they have a value
        if linkCode is not None:
            body["linkCode"] = linkCode
        if linkDeviceId is not None:
            body["linkDeviceId"] = linkDeviceId

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def startDirectControlEx(self, serviceId=None, linkCode=None, appId=None, linkDeviceId=None, restartToken=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use this command to initiate a dedicated playback session through the player. For example, this is useful if you implement your session initiation logic in the cloud. Or with a third party application. In this case, the player acts as a proxy.

        This command changed in v1.11.0 to use a groupId target instead of the namespace default (householdId).

        This method was autogenerated from the musicServiceAccounts namespace xml definition
        :param serviceId: (Required) The unique identifier for the music service or psuedo-music service.
        :param linkCode: (Required) OAuth using link code. Used to identify a user account.
        :param appId: (Optional) (Optional) This parameter identifies the application that is requesting to start direct control. This allows Sonos to track the origin of direct control.
        :param linkDeviceId: (Optional) (Optional) Private data associated with the link code to prevent phishing. Used for SMAPI services that return a Link Device Id value with getDeviceAuthToken responses.
        :param restartToken: (Optional) (Optional) This string is passed to the partner service when logging into the backend. It is used to control the content that is loaded on the player.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: musicServiceAccountEvent groupCoordinatorChangedEvent globalErrorEvent
        """

        header = {
            "namespace": "musicServiceAccounts",
            "command": "startDirectControlEx",
            "groupId": self._museConnection.getGroupId()
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if serviceId is None:
                missing_list.append('serviceId')
            if linkCode is None:
                missing_list.append('linkCode')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'serviceId': serviceId,
            'linkCode': linkCode,
        }

        # Only send optional parameters if they have a value
        if appId is not None:
            body["appId"] = appId
        if linkDeviceId is not None:
            body["linkDeviceId"] = linkDeviceId
        if restartToken is not None:
            body["restartToken"] = restartToken

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def endDirectControl(self, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        This group-targeted command stops the current direct control session. If there is no active direct control session, this command has no effect.

        This method was autogenerated from the musicServiceAccounts namespace xml definition
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: groupCoordinatorChangedEvent
        """

        header = {
            "namespace": "musicServiceAccounts",
            "command": "endDirectControl",
            "groupId": self._museConnection.getGroupId()
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]


# This class was automatically generated and should only be edited via namespace-client.py.template
class networkTestClient(object):
    """
    [Sonos private internal command]
    This namespace enables the controller to test player connectivity as nodes are removed from the network mesh.
    """

    def __init__(self, museWebsocketClient):
        self._museConnection = museWebsocketClient

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def temporarilyDisableNetwork(self, delaySecs=None, durationSecs=None, oauthToken=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        [Sonos private internal command]
        Direct the player to disable wired and wireless networking.

        The player will wait for delaySecs and then take down it's network interface for the window of
        time specified by durationSecs. The effect is removing the device from the network mesh.

        This will allow us to test the network with the device absent from the mesh.

        This method was autogenerated from the networkTest namespace xml definition
        :param delaySecs: (Required) Number of seconds to delay before disabling all networking on the target player.
        :param durationSecs: (Required) Number of seconds to disable all networking on the target player.
            This timer starts after the delaySecs timer has expired.
        :param oauthToken: (Required) HH_CONFIG_ADMIN scoped oauth token
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: globalErrorEvent
        """

        header = {
            "namespace": "networkTest",
            "command": "temporarilyDisableNetwork",
            "playerId": self._museConnection.uuid
        }

        oauthToken = self._museConnection.hhConfigAdminToken if oauthToken is None else oauthToken
        # Verified required oauthToken param is not None
        assert oauthToken is not None, "Command requires an oauthToken param"
        header["authorization"] = "bearer {}".format(oauthToken)
        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if delaySecs is None:
                missing_list.append('delaySecs')
            if durationSecs is None:
                missing_list.append('durationSecs')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'delaySecs': delaySecs,
            'durationSecs': durationSecs,
        }

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def startNetworkTests(self, url=None, delaySecs=None, durationSecs=None, oauthToken=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        [Sonos private internal command]
        Direct the player to run the connectivity test set.

        The player will then independantly run through the network tests. The test results are stored in RAM so
        that they can later be retrieved for reporting by getNetworkConnectivityTestResults. The player will
        only maintain one report, overwriting previous reports as new tests are run.

        This method was autogenerated from the networkTest namespace xml definition
        :param url: (Required) Url of endpoint to attempt to connect.

            HTTPS endpoints are dissallowed, the url must start with "http:".
        :param delaySecs: (Required) Number of seconds to delay before disabling all networking on the target player.
        :param durationSecs: (Required) Number of seconds to disable all networking on the target player.
            This timer starts after the delaySecs timer has expired.
        :param oauthToken: (Required) HH_CONFIG_ADMIN scoped oauth token
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: networkTestIdEvent globalErrorEvent
        """

        header = {
            "namespace": "networkTest",
            "command": "startNetworkTests",
            "playerId": self._museConnection.uuid
        }

        oauthToken = self._museConnection.hhConfigAdminToken if oauthToken is None else oauthToken
        # Verified required oauthToken param is not None
        assert oauthToken is not None, "Command requires an oauthToken param"
        header["authorization"] = "bearer {}".format(oauthToken)
        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if url is None:
                missing_list.append('url')
            if delaySecs is None:
                missing_list.append('delaySecs')
            if durationSecs is None:
                missing_list.append('durationSecs')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'url': url,
            'delaySecs': delaySecs,
            'durationSecs': durationSecs,
        }

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def getNetworkTestResults(self, oauthToken=None, networkTestId=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        [Sonos private internal command]
        Query the player for it's test set, uniquely identified via networkTestId.

        This method was autogenerated from the networkTest namespace xml definition
        :param networkTestId: (Optional) The unique report identifier.
        :param oauthToken: (Required) HH_CONFIG_ADMIN scoped oauth token
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: networkTestResultEvent globalErrorEvent
        """

        header = {
            "namespace": "networkTest",
            "command": "getNetworkTestResults",
            "playerId": self._museConnection.uuid
        }

        oauthToken = self._museConnection.hhConfigAdminToken if oauthToken is None else oauthToken
        # Verified required oauthToken param is not None
        assert oauthToken is not None, "Command requires an oauthToken param"
        header["authorization"] = "bearer {}".format(oauthToken)
        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        # Only send optional parameters if they have a value
        if networkTestId is not None:
            body["networkTestId"] = networkTestId

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]


# This class was automatically generated and should only be edited via namespace-client.py.template
class platformInternalClient(object):
    """
    This namespace is a placeholder for useful commands that are not appropriate for the open
    developer program. These commands are internally useful, however.
    """

    def __init__(self, museWebsocketClient):
        self._museConnection = museWebsocketClient

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def sync(self, setting=None, fullSync=None, operation=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        This command allows cloud services to poke the player whenever something changes. We use
        this command instead of long polling from the player. It is currently used with the
        Music Account Service.

        This method was autogenerated from the platformInternal namespace xml definition
        :param setting: (Required) This parameter identifies the data set that has changed.
        :param fullSync: (Optional) This parameter instructs the receiver to perform a full sync instead of
            a partial (delta) sync.
        :param operation: (Optional) This parameter customizes the direction of the operation. Incoming / Outgoing.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: globalErrorEvent
        """

        header = {
            "namespace": "platformInternal",
            "command": "sync",
            "householdId": self._museConnection.hhid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if setting is None:
                missing_list.append('setting')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'setting': setting,
        }

        # Only send optional parameters if they have a value
        if fullSync is not None:
            body["fullSync"] = fullSync
        if operation is not None:
            body["operation"] = operation

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def reboot(self, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        This command reboots the player. This is a kernel reboot, not a restart of anacapa.

        This method was autogenerated from the platformInternal namespace xml definition
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: globalErrorEvent
        """

        header = {
            "namespace": "platformInternal",
            "command": "reboot",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def invalidateCache(self, cacheName=None, cacheKey=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Cloud services and players can invalidate individual player cache records (or entire
        caches) with this command. This command is currently used by the Authorization Service,
        to allow the service to pre-empt the default 24 hour expiration time of cache records.

        This method was autogenerated from the platformInternal namespace xml definition
        :param cacheName: (Optional) This parameter specifies the cache whose records callers seek to invalidate. If no
            specific cacheKey value is passed in the invalidateCache command's request body, the
            entire cache will be invalidated.
        :param cacheKey: (Optional) This parameter specifies which cache record to invalidate. The entire cache will be
            invalidated if this parameter is not set.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: globalErrorEvent
        """

        header = {
            "namespace": "platformInternal",
            "command": "invalidateCache",
            "householdId": self._museConnection.hhid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        # Only send optional parameters if they have a value
        if cacheName is not None:
            body["cacheName"] = cacheName
        if cacheKey is not None:
            body["cacheKey"] = cacheKey

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]


# This class was automatically generated and should only be edited via namespace-client.py.template
class playbackClient(object):
    """
    The "playback" namespace contains general commands and events that can be used by clients that
    wish to control the transport state of a group but don't need to know exactly what is currently
    playing. The playback namespace also exposes the current and available play modes (repeat,
    shuffle, crossfade) and playback policies (canSkip, etc.). Commands in this namespace can return
    global errors or playbackError responses.
    """

    def __init__(self, museWebsocketClient):
        self._museConnection = museWebsocketClient

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def subscribe(self, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use this command to subscribe to events in the playback namespace.

        This method was autogenerated from the playback namespace xml definition
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: groupCoordinatorChangedEvent
        """

        header = {
            "namespace": "playback",
            "command": "subscribe",
            "groupId": self._museConnection.getGroupId()
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def unsubscribe(self, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use this command to unsubscribe to events in the playback namespace.

        This method was autogenerated from the playback namespace xml definition
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: groupCoordinatorChangedEvent
        """

        header = {
            "namespace": "playback",
            "command": "unsubscribe",
            "groupId": self._museConnection.getGroupId()
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def getPlaybackStatus(self, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use the getPlaybackStatus command in the playback namespace get the current playback status (transport state) for the group, such as PLAYBACK_STATE_IDLE, PLAYBACK_STATE_BUFFERING, or PLAYBACK_STATE_PLAYING. See the playbackStatus object for details.

        This method was autogenerated from the playback namespace xml definition
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: playbackStatusEvent groupCoordinatorChangedEvent
        """

        header = {
            "namespace": "playback",
            "command": "getPlaybackStatus",
            "groupId": self._museConnection.getGroupId()
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def play(self, allowTvPauseRestore=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use the play command in the playback namespace to initiate group playback.

        After a successful play command, if your app is subscribed to the playback namespace, it may first receive a playbackStatus event with PLAYBACK_STATE_BUFFERING before another event with PLAYBACK_STATE_PLAYING. Sonos players will buffer the audio ahead of time when possible, in order to provide the shortest time to play for the user, and to prevent any audio gaps between tracks.

        This method was autogenerated from the playback namespace xml definition
        :param allowTvPauseRestore: (Optional) If true, an attempt is made to restore the TV audio stream that was stopped from a prior "pause" command.
            This will have no effect if a prior "pause" command did not run or did not stop a TV audio stream.
            This is intended for internal use only because TV audio streams are not supported to be paused or stopped by clients.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: playbackErrorEvent groupCoordinatorChangedEvent
        """

        header = {
            "namespace": "playback",
            "command": "play",
            "groupId": self._museConnection.getGroupId()
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        # Only send optional parameters if they have a value
        if allowTvPauseRestore is not None:
            body["allowTvPauseRestore"] = allowTvPauseRestore

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def pause(self, allowTvPauseRestore=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use the pause command in the playback namespace to pause group playback.

        After a successful pause command, if your app is subscribed to the playback namespace, it will receive a playbackStatus event with either PLAYBACK_STATE_PAUSED or PLAYBACK_STATE_IDLE, depending on the audio source loaded on the group.

        This method was autogenerated from the playback namespace xml definition
        :param allowTvPauseRestore: (Optional) If true, an attempt is made to pause the TV audio stream if it's playing (by default, it cannot be paused).
            The TV audio stream can resume with the "play" command if "allowTvPauseRestore" is also true.
            This is intended for internal use only because TV audio streams are not supported to be paused or stopped by clients.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: playbackErrorEvent groupCoordinatorChangedEvent
        """

        header = {
            "namespace": "playback",
            "command": "pause",
            "groupId": self._museConnection.getGroupId()
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        # Only send optional parameters if they have a value
        if allowTvPauseRestore is not None:
            body["allowTvPauseRestore"] = allowTvPauseRestore

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def togglePlayPause(self, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use the togglePlayPause command in the playback namespace to toggle the playback state on the given group, if possible. Upon completion of the command, the player sends playbackStatus events to all subscribers. When toggling from pause to play, this functions similar to the play command. When transitioning from play to pause, it functions like the pause command. See those commands for more details about the functionality of those states.

        This method was autogenerated from the playback namespace xml definition
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: playbackErrorEvent groupCoordinatorChangedEvent
        """

        header = {
            "namespace": "playback",
            "command": "togglePlayPause",
            "groupId": self._museConnection.getGroupId()
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def setPlayModes(self, playModes=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use the setPlayModes command in the playback namespace to change group play modes, such as repeat, repeat one track, shuffle, and crossfade. See Play Modes for details.

        Configure a play mode in the playModes array by adding a true or false value for the mode, or omit a play mode to leave it unchanged.

        This method was autogenerated from the playback namespace xml definition
        :param playModes: (Required) An array of play modes that define the functionality of one or more play modes: repeat, repeatOne, shuffle, and crossfade. Any omitted play modes remain unchanged. See the playMode type for details.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: groupCoordinatorChangedEvent
        """

        header = {
            "namespace": "playback",
            "command": "setPlayModes",
            "groupId": self._museConnection.getGroupId()
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if playModes is None:
                missing_list.append('playModes')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'playModes': playModes,
        }

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def skipToNextTrack(self, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use the skipToNextTrack command in the playback namespace to skip to the next track.

        Not all audio sources allow multiple tracks. For example, when a group is streaming an Internet radio station, there is no next track to skip to. If you send a skipToNextTrack command when the audio source does not support multiple tracks, your app will receive an ERROR_PLAYBACK_FAILED, but the audio will continue playing.

        This method was autogenerated from the playback namespace xml definition
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: playbackErrorEvent groupCoordinatorChangedEvent
        """

        header = {
            "namespace": "playback",
            "command": "skipToNextTrack",
            "groupId": self._museConnection.getGroupId()
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def skipToPreviousTrack(self, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use the skipToPreviousTrack command in the playback namespace to skip to the previous track.

        Not all audio sources allow multiple tracks. For example, when a group is streaming an Internet radio station, there is no previous track to skip to. If you send a skipToPreviousTrack command when the audio source does not support multiple tracks, your app will receive an ERROR_PLAYBACK_FAILED, but audio will continue playing.

        This method was autogenerated from the playback namespace xml definition
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: playbackErrorEvent groupCoordinatorChangedEvent
        """

        header = {
            "namespace": "playback",
            "command": "skipToPreviousTrack",
            "groupId": self._museConnection.getGroupId()
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def seek(self, positionMillis=None, itemId=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use the seek command in the playback namespace to go to a specific position in the current track. Optionally add the cloud queue itemId to target a specific track.

        Use itemId to ensure the group seeks on the current item. If the current items itemId does not match the one provided, the player returns an ERROR_INVALID_OBJECT_ID error.

        This method was autogenerated from the playback namespace xml definition
        :param positionMillis: (Required) Position within track in milliseconds. If this value exceeds the current track duration time, Sonos moves to the end of the current track, which results in a skip to the next track.
        :param itemId: (Optional) (Optional) The identifier for the item. If included and it does not match the currently playing item, the command fails. This ensures that playback does not jump back to a track if a user starts to scrub just as the player begins to play the next item or due to latency.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: playbackErrorEvent groupCoordinatorChangedEvent
        """

        header = {
            "namespace": "playback",
            "command": "seek",
            "groupId": self._museConnection.getGroupId()
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if positionMillis is None:
                missing_list.append('positionMillis')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'positionMillis': positionMillis,
        }

        # Only send optional parameters if they have a value
        if itemId is not None:
            body["itemId"] = itemId

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def seekRelative(self, deltaMillis=None, itemId=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use the seekRelative command in the playback namespace to seek to the a relative position in the current track. Optionally add the cloud queue itemId to target a specific track.

        Use itemId to ensure the group seeks on the current item. If the current items itemId does not match the one provided, the player returns ERROR_INVALID_OBJECT_ID.

        This method was autogenerated from the playback namespace xml definition
        :param deltaMillis: (Required) Relative position within track in milliseconds. If this value exceeds the current track duration time, Sonos moves to the end of the current track, which results in a skip to the next track.
        :param itemId: (Optional) (Optional) The identifier for the item. If this parameter does not match the currently playing item, the command fails. This ensures that playback does not jump back to a track if a user starts to scrub just as the player begins to play the next item.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: playbackErrorEvent groupCoordinatorChangedEvent
        """

        header = {
            "namespace": "playback",
            "command": "seekRelative",
            "groupId": self._museConnection.getGroupId()
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if deltaMillis is None:
                missing_list.append('deltaMillis')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'deltaMillis': deltaMillis,
        }

        # Only send optional parameters if they have a value
        if itemId is not None:
            body["itemId"] = itemId

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def loadContainer(self, containerId=None, containerMetadata=None, action=None, playModes=None, playOnCompletion=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Replaces or adds tracks to Sonos, with or without shuffling them. The player customizes
        media enqueuing based on the container type. The following containers are supported:

        - programmed radio (trackList.program) uses the AVT queue
        - audiobooks (audiobook) use the AVT queue
        - radio streams () use the AVT queue
        - service playlists, album, playlists, etc. are expanded into the shared queue. The Sonos
          shared queue is set to be the current source (if it is not already).


        The playModes only apply to content that uses the shared queue. The playhead position
        (current track) is not changed if action is "APPEND" or "PLAY_NEXT."  The playhead position is
        set to the first (possibly shuffled) track if action is "REPLACE." The playhead position is
        set to the first inserted track if action is "PLAY_NOW."

        The player's shuffle mode is updated to match the playModes.shuffle parameter value (if it is
        not null).

        This method was autogenerated from the playback namespace xml definition
        :param containerId: (Required) The id of the container whose tracks will be loaded into the shared queue. The objectId and one of serviceId or
            accountId is required for the player to uniquely identify the content. 
            
            note: The accountId parameter is specific to the muse householdId today.
        :param containerMetadata: (Required) Metadata describing the container (e.g. the name of the playlist, album, etc.).
            Most attributes of containerMetadata are optional, but "name" is highly desirable for a good
            end-user experience. The "type" is required for the player to choose the correct audio playback.

            See also:
            - Sonos API Item Types II
            - Muse Protocol - Container object
        :param action: (Optional) Indicates how the tracks are added into the shared queue.
        :param playModes: (Optional) This argument only applies to content that uses the shared queue.

            If playModes.shuffle is true, the new tracks will be shuffled when added to the shared
            queue. The shared queue's shuffle mode will be turned on if it is not already on.

            If playModes.shuffle is false, the shuffle mode on the player will be turned off and
            the tracks will be added in their normal order.

            If playModes.shuffle is null, the current shuffle mode of the player will be retained
            and respected.
        :param playOnCompletion: (Optional) If true, then playback of the station will begin if it is succesfully loaded.

            If false, then the playbackState will be "PLAYBACK_IDLE"

            If null, then:

            - if action="APPEND" or "PLAY_NEXT", the playbackState is unaffected
            - if action="REPLACE", the playbackState is set to "PLAYBACK_IDLE"
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: accountErrorEvent groupCoordinatorChangedEvent globalErrorEvent
        """

        header = {
            "namespace": "playback",
            "command": "loadContainer",
            "groupId": self._museConnection.getGroupId()
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if containerId is None:
                missing_list.append('containerId')
            if containerMetadata is None:
                missing_list.append('containerMetadata')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'containerId': containerId,
            'containerMetadata': containerMetadata,
        }

        # Only send optional parameters if they have a value
        if action is not None:
            body["action"] = action
        if playModes is not None:
            body["playModes"] = playModes
        if playOnCompletion is not None:
            body["playOnCompletion"] = playOnCompletion

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def loadTrackList(self, containerMetadata=None, tracks=None, action=None, playModes=None, playOnCompletion=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Loads a list of tracks into the shared queue.

        This method was autogenerated from the playback namespace xml definition
        :param containerMetadata: (Required) Metadata describing the list of tracks.

            All attributes of containerMetadata are optional, but "name" is highly desirable for a good end-user experience.
        :param tracks: (Optional) This parameter is limited by the maximum number of tracks in the queue, but the player might run out
            of memory first. The command will fail when the player exhausts all of its queue memory.
        :param action: (Optional) Indicates how the new tracks are added/merged into the shared queue.
        :param playModes: (Optional) Sonos players support audio play modes including shuffle, repeat, and crossfade. Your app can receive notifications for changes with the playbackStatus event and set the current play modes with the setPlayModes command.

            The playMode type defines the functionality of one or more play modes. Play modes are either enabled or disabled.
        :param playOnCompletion: (Optional) If present, the player will either transition to playing (true) or paused/stopped (false) depending on the value of the boolean.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: groupCoordinatorChangedEvent globalErrorEvent
        """

        header = {
            "namespace": "playback",
            "command": "loadTrackList",
            "groupId": self._museConnection.getGroupId()
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if containerMetadata is None:
                missing_list.append('containerMetadata')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'containerMetadata': containerMetadata,
        }

        # Only send optional parameters if they have a value
        if tracks is not None:
            body["tracks"] = tracks
        if action is not None:
            body["action"] = action
        if playModes is not None:
            body["playModes"] = playModes
        if playOnCompletion is not None:
            body["playOnCompletion"] = playOnCompletion

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def loadStream(self, stationId=None, playOnCompletion=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        This command is used to load a SMAPI stream onto the player. Terrestrial radio stations
        are usually considered streams.

        This method was autogenerated from the playback namespace xml definition
        :param stationId: (Required) The ID of the station to play.
        :param playOnCompletion: (Optional) If present, the player will either transition to playing (true) or paused/stopped (false) depending on the value of the boolean.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: accountErrorEvent groupCoordinatorChangedEvent globalErrorEvent
        """

        header = {
            "namespace": "playback",
            "command": "loadStream",
            "groupId": self._museConnection.getGroupId()
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if stationId is None:
                missing_list.append('stationId')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'stationId': stationId,
        }

        # Only send optional parameters if they have a value
        if playOnCompletion is not None:
            body["playOnCompletion"] = playOnCompletion

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def loadLineIn(self, deviceId=None, playOnCompletion=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use the loadLineIn command in the playback namespace to change the current group source to the line-in source of a specified player. This can be be any player in the household that supports line-in. See Using Line-In on Sonos on the Sonos Support site for more details about the line-in capabilities of our players.

        You can tell whether a player has line-in capabilities with the LINE_IN value in the capabilities object. See the groups object for details.

        The player will switch away from the line-in source when the hardware detects that the user has physically unplugged the line-in cable.

        This method was autogenerated from the playback namespace xml definition
        :param deviceId: (Optional) (Optional) Represents the line-in source, any player in the household that supports line-in. The default value is the local deviceId. This is the same as the player ID returned in the player object.
        :param playOnCompletion: (Optional) (Optional) If true, start playback after loading the line-in source. If false, the player loads the cloud queue, but requires the play command to begin. If not provided, the default value is false.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: groupCoordinatorChangedEvent globalErrorEvent
        """

        header = {
            "namespace": "playback",
            "command": "loadLineIn",
            "groupId": self._museConnection.getGroupId()
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        # Only send optional parameters if they have a value
        if deviceId is not None:
            body["deviceId"] = deviceId
        if playOnCompletion is not None:
            body["playOnCompletion"] = playOnCompletion

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]


# This class was automatically generated and should only be edited via namespace-client.py.template
class playbackExtendedClient(object):
    """
    This namespace is a logical combination of the playback and playbackMetadata namespaces. It
    contains no new information. The value of this namespace is that all playback and
    playbackMetadata data is delivered together. This is especially useful for event delivery.
    """

    def __init__(self, museWebsocketClient):
        self._museConnection = museWebsocketClient

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def subscribe(self, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use this command to subscribe to events in the playback namespace.

        This method was autogenerated from the playbackExtended namespace xml definition
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: groupCoordinatorChangedEvent
        """

        header = {
            "namespace": "playbackExtended",
            "command": "subscribe",
            "groupId": self._museConnection.getGroupId()
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def unsubscribe(self, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use this command to unsubscribe to events in the playback namespace.

        This method was autogenerated from the playbackExtended namespace xml definition
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: groupCoordinatorChangedEvent
        """

        header = {
            "namespace": "playbackExtended",
            "command": "unsubscribe",
            "groupId": self._museConnection.getGroupId()
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def getExtendedPlaybackStatus(self, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use this command to fetch the playbackStatus (playback) and playbackMetadataStatus (playbackMetadata) events types
        together in a single playload.

        This method was autogenerated from the playbackExtended namespace xml definition
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: extendedPlaybackStatusEvent groupCoordinatorChangedEvent
        """

        header = {
            "namespace": "playbackExtended",
            "command": "getExtendedPlaybackStatus",
            "groupId": self._museConnection.getGroupId()
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]


# This class was automatically generated and should only be edited via namespace-client.py.template
class playbackMetadataClient(object):
    """
    The playbackMetadata namespace includes commands and events that enable your app to receive notification
    on changes to metadata for the currently playing track and the next track.
    """

    def __init__(self, museWebsocketClient):
        self._museConnection = museWebsocketClient

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def subscribe(self, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use this command to subscribe to events in the playbackMetadata namespace.

          Returns an empty body with a success value of true if successful and sends a metadataStatus event only to the subscriber.

        This method was autogenerated from the playbackMetadata namespace xml definition
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: groupCoordinatorChangedEvent
        """

        header = {
            "namespace": "playbackMetadata",
            "command": "subscribe",
            "groupId": self._museConnection.getGroupId()
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def unsubscribe(self, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use this command to unsubscribe to events in the playbackMetadata namespace.

          Returns an empty body with a success value of true if successful.

        This method was autogenerated from the playbackMetadata namespace xml definition
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: groupCoordinatorChangedEvent
        """

        header = {
            "namespace": "playbackMetadata",
            "command": "unsubscribe",
            "groupId": self._museConnection.getGroupId()
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def getMetadataStatus(self, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use this command to poll for metadata changes. This command returns a metadataStatus object for the target group.

        This method was autogenerated from the playbackMetadata namespace xml definition
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: metadataStatusEvent groupCoordinatorChangedEvent
        """

        header = {
            "namespace": "playbackMetadata",
            "command": "getMetadataStatus",
            "groupId": self._museConnection.getGroupId()
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def rate(self, itemId=None, rating=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        This command is used to rate content. The rating is submitted to the associated playback server. The playback server is determined from the itemId.
        This is only implemented for cloud queue content (programmed radio).

        This method was autogenerated from the playbackMetadata namespace xml definition
        :param itemId: (Required) The ID of the rated object.
        :param rating: (Required) This is how the operator rates the content. This object is passed to the playback server.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: rateStatusEvent groupCoordinatorChangedEvent globalErrorEvent
        """

        header = {
            "namespace": "playbackMetadata",
            "command": "rate",
            "groupId": self._museConnection.getGroupId()
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if itemId is None:
                missing_list.append('itemId')
            if rating is None:
                missing_list.append('rating')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'itemId': itemId,
            'rating': rating,
        }

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]


# This class was automatically generated and should only be edited via namespace-client.py.template
class playbackSessionClient(object):
    """
    Sessions let one or more apps load and control playback of a cloud queue.

    The playbackSession namespace includes commands and events that enable apps to create a new session, or join an existing session in a group. Once your app has joined a session, it can load and start playback of an item in a cloud queue. Your app can also skip or seek to a specific item in a cloud queue, ask the group to re-fetch items in the cloud queue, or disconnect from the session. Your app can also get notified with a session error that your session was evicted or terminated at any time, for example, when another app starts playing something else.
    """

    def __init__(self, museWebsocketClient):
        self._museConnection = museWebsocketClient

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def subscribe(self, sid=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use this command to subscribe to events in the playbackSession namespace for a specific sessionId. Your app can only be subscribed to one session at a time.

        Returns an empty body with a success value of true if successful.

        This method was autogenerated from the playbackSession namespace xml definition
        :param sid: (Required) Target session ID
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: groupCoordinatorChangedEvent globalErrorEvent
        """

        header = {
            "namespace": "playbackSession",
            "command": "subscribe",
            "sessionId": sid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def unsubscribe(self, sid=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use this command to unsubscribe to events in the playbackSession namespace.

        Returns an empty body with a success value of true if successful.

        This method was autogenerated from the playbackSession namespace xml definition
        :param sid: (Required) Target session ID
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: groupCoordinatorChangedEvent globalErrorEvent
        """

        header = {
            "namespace": "playbackSession",
            "command": "unsubscribe",
            "sessionId": sid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def joinOrCreateSession(self, appId=None, appContext=None, accountId=None, customData=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Warning: This command, along with all other playbackSession commands used to join or leave sessions over a persistent connections with the player, has been deprecated. The client must still create a session with the createSession command, and the generated sessionId should be cached and used with subsequent commands.

        Use the joinOrCreateSession command in the playbackSession namespace to join an existing session in the group, if the appId and appContext match the existing sessions. If there is no current session and no other source is playing, joinOrCreateSession creates a new session and joins it.

        While this same behavior can be achieved by first calling joinSession and then conditionally calling createSession, using joinOrCreateSession guarantees that another app cannot create a session in between the two commands.

        Use appContext to determine how multiple instances of your app can share control of a session. For example, if you provide a user account identifier as appContext, then two instances of your app logged into the same user account would be able to control the same session on a group. If you choose to implement your app to always provide an appContext that is unique for all app instances, then only one app instance can control a session at any time.

        Use customData to save information in the session that your app finds useful. For example, your app could store a playlist identifier in customData, so that another app instance could automatically load the right playlist when joining a session.

        This method was autogenerated from the playbackSession namespace xml definition
        :param appId: (Required) Identifies your app. This should be a reverse DNS name of the form com.companyname.appname or similar. It is used together with appContext to determine if a session can be joined or not. As a best practice, user-identifiable data should be hashed or encoded so that it is only useful to your app.The sum total length of appId and appContext must be less than 255 bytes. Otherwise, the player will return an error.
        :param appContext: (Required) Instance data for your app, an opaque string that you can use to identify a particular user account, for example. It is used together with appId to determine if a session can be joined or not. As a best practice, user-identifiable data should be hashed or encoded so that it is only useful to your app.

            The sum total length of appId and appContext must be less than 255 bytes. Otherwise, the player will return an error.
        :param accountId: (Optional) (Optional) The music service account to use on Sonos for playback in the session. See the MusicObjectId for more details about this parameter. If your app submits an invalid accountId, you will receive an ERROR_INVALID_PARAMETER error. An accountId is invalid when it doesnt match a stored account on the player.
        :param customData: (Optional) (Optional) A blob of text stored by the player and passed back to any other clients that successfully join an existing session. This data (up to 1023 bytes) is stored within the session. The player truncates blobs of text that are longer than 1023 bytes and returns the truncated string in the command response. The default value is . As a best practice, user-identifiable data should be hashed or encoded so that it is only useful to your app.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: accountErrorEvent sessionStatusEvent sessionErrorEvent groupCoordinatorChangedEvent globalErrorEvent
        """

        header = {
            "namespace": "playbackSession",
            "command": "joinOrCreateSession",
            "groupId": self._museConnection.getGroupId()
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if appId is None:
                missing_list.append('appId')
            if appContext is None:
                missing_list.append('appContext')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'appId': appId,
            'appContext': appContext,
        }

        # Only send optional parameters if they have a value
        if accountId is not None:
            body["accountId"] = accountId
        if customData is not None:
            body["customData"] = customData

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def joinSession(self, appId=None, appContext=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Warning: This command, along with all other playbackSession commands used to join or leave sessions over a persistent connections with the player, has been deprecated. The client must still create a session with the createSession command, and the generated sessionId should be cached and used with subsequent commands.

        Use the joinSession command in the playbackSession namespace to join an existing session in the group. To successfully join the session your app will have to provide the same appId and appContext that was used when creating the session.

        This method was autogenerated from the playbackSession namespace xml definition
        :param appId: (Required) Identifies your app. This should be a reverse DNS name of the form com.companyname.appname or similar. It is used together with appContext to determine if a session can be joined or not. As a best practice, user-identifiable data should be hashed or encoded so that it is only useful to your app.

            The sum total length of appId and appContext must be less than 255 bytes. Otherwise, the player will return an error.
        :param appContext: (Required) Instance data for your app, an opaque string that you can use to identify a particular user account, for example. It is used together with appId to determine if a session can be joined or not. As a best practice, user-identifiable data should be hashed or encoded so that it is only useful to your app.

            The sum total length of appId and appContext must be less than 255 bytes. Otherwise, the player will return an error.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: sessionStatusEvent sessionErrorEvent groupCoordinatorChangedEvent globalErrorEvent
        """

        header = {
            "namespace": "playbackSession",
            "command": "joinSession",
            "groupId": self._museConnection.getGroupId()
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if appId is None:
                missing_list.append('appId')
            if appContext is None:
                missing_list.append('appContext')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'appId': appId,
            'appContext': appContext,
        }

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def rejoinSession(self, sid=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Warning: This command, along with all other playbackSession commands used to join or leave sessions over a persistent connections with the player, has been deprecated. The client must still create a session with the createSession command, and the generated sessionId should be cached and used with subsequent commands.

        Rejoins an existing session. This command joins the current session if the session ID matches the current session ID.

        NOTE: This command can only be called by Lechmere to support managing sessions for cloud-based clients when groups move on the LAN.

        This method was autogenerated from the playbackSession namespace xml definition
        :param sid: (Required) Target session ID
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: groupCoordinatorChangedEvent sessionErrorEvent globalErrorEvent
        """

        header = {
            "namespace": "playbackSession",
            "command": "rejoinSession",
            "sessionId": sid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def createSession(self, appId=None, appContext=None, accountId=None, customData=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use the createSession command in the playbackSession namespace to unconditionally create a new session and clobber any existing sessions.

        Use appContext to determine how multiple instances of your app can share control of a session. For example, if you provide a user account identifier as appContext, then two instances of your app logged into the same user account would be able to control the same session on a group. If you choose to implement your app to always provide an appContext that is unique for all app instances, then only one app instance can control a session at any time.

        Use customData to save information in the session that your app finds useful. For example, your app could store a playlist identifier in customData, so that another app instance could automatically load the right playlist when joining a session.

        This method was autogenerated from the playbackSession namespace xml definition
        :param appId: (Required) Identifies your app. This should be a reverse DNS name of the form com.companyname.appname or similar. It is used together with appContext to determine if a session can be joined or not. As a best practice, user-identifiable data should be hashed or encoded so that it is only useful to your app.

            The sum total length of appId and appContext must be less than 255 bytes. Otherwise, the player will return an error.
        :param appContext: (Required) Instance data for your app, an opaque string that you can use to identify a particular user account, for example. It is used together with appId to determine if a session can be joined or not. As a best practice, user-identifiable data should be hashed or encoded so that it is only useful to your app.

            The sum total length of appId and appContext must be less than 255 bytes. Otherwise, the player will return an error.
        :param accountId: (Optional) (Optional) The music service account to use on Sonos for playback in the session. See the MusicObjectId for more details about this parameter. If your app submits an invalid accountId, you will receive an ERROR_INVALID_PARAMETER error. An accountId is invalid when it doesnt match a stored account on the player.
        :param customData: (Optional) (Optional) A blob of text stored by the player and passed back to any other clients that successfully join an existing session. This data (up to 1023 bytes) is stored within the session. The player truncates blobs of text that are longer than 1023 bytes and returns the truncated string in the command response. The default value is an empty string (). As a best practice, user-identifiable data should be hashed or encoded so that it is only useful to your app.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: accountErrorEvent sessionStatusEvent sessionErrorEvent groupCoordinatorChangedEvent globalErrorEvent
        """

        header = {
            "namespace": "playbackSession",
            "command": "createSession",
            "groupId": self._museConnection.getGroupId()
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if appId is None:
                missing_list.append('appId')
            if appContext is None:
                missing_list.append('appContext')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'appId': appId,
            'appContext': appContext,
        }

        # Only send optional parameters if they have a value
        if accountId is not None:
            body["accountId"] = accountId
        if customData is not None:
            body["customData"] = customData

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def suspend(self, sid=None, queueVersion=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use the suspend command in the playbackSession namespace to suspend a specified session. The player will clear the stored item window of tracks and send a playbackStatus event to tell clients that the current item is null.

        As described in a cloud queue use case in Play audio, if your app sends a play command when the cloud queue is empty, the player will attempt to resume playback of content that was playing prior to this command. For example, if the user was previously listening to a radio station or had a playlist queued, it will attempt to resume playback of that content.

        When a session is suspended, the player wont revert to the previous music source in this case. Instead, the player delivers a sessionInfo event with a suspended value of true for the suspended session. The session stays suspended until one of the following occurs:

          The player receives a play command. If the player receives a play command, it sends a sessionInfo event with a suspended value of false.
          The player receives either a loadCloudQueue or skipToItem command for the suspended session. The player follows these commands as specified.
          The player receives a createSession command. The suspended session receives an ERROR_SESSION_EVICTED sessionError.
          The user or an action picks a new music source. This can either be from the Sonos app or through the loadFavorite command. The suspended session receives an ERROR_SESSION_EVICTED sessionError.

        This method was autogenerated from the playbackSession namespace xml definition
        :param sid: (Required) Target session ID
        :param queueVersion: (Optional) (Optional) The player will store this value locally. The cloud queue server should return this queue version in all GET /version and GET /itemWindow responses while the player is suspended.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: groupCoordinatorChangedEvent globalErrorEvent
        """

        header = {
            "namespace": "playbackSession",
            "command": "suspend",
            "sessionId": sid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        # Only send optional parameters if they have a value
        if queueVersion is not None:
            body["queueVersion"] = queueVersion

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def leaveSession(self, sid=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Warning: This command, along with all other playbackSession commands used to join or leave sessions over a persistent connections with the player, has been deprecated. The client must still create a session with the createSession command, and the generated sessionId should be cached and used with subsequent commands.

        Leaves (disconnects from) the given playback session.  The player is responsible for tracking the number of clients connected to the session.  When the number of connected clients transitions from 1 to 0 due to an explicit leaveSession command, then the player stops playback and delivers sessionError(ERROR_SESSION_EVICTED) to any clients still subscribed to the session ID. In all other cases, including when the number of connected clients reaches 0 due to an implicit disconnect, then the player maintains playback and keeps the session alive until such time as the music service ends authorization for the stream.

        Generally, a client should call leaveSession only in response to an explicit user action to stop controlling to the Sonos group.  Changing the queue does not require a new session.  Simply call loadCloudQueue with new parameters.
        
        NOTE: Leaving the session does not implicitly unsubscribe a client from receiving playbackSession events. A subscribed client will continue to receive events related to the session until explicitly calling unsubscribe. 
        This command is only available on the LAN.

        This method was autogenerated from the playbackSession namespace xml definition
        :param sid: (Required) Target session ID
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: groupCoordinatorChangedEvent globalErrorEvent
        """

        header = {
            "namespace": "playbackSession",
            "command": "leaveSession",
            "sessionId": sid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def loadQueue(self, sid=None, metadata=None, policies=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Initializes the (private) queue with custom metadata and playback policies. This command is used with skipToItemWithWindow to feed tracks into the player.

        This method was autogenerated from the playbackSession namespace xml definition
        :param sid: (Required) Target session ID
        :param metadata: (Optional) Container metadata describing the queue. This could be Programmed Radio, an album, a Playlist, etc.
        :param policies: (Optional) Playback policies that describe the direct control integration.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: groupCoordinatorChangedEvent globalErrorEvent
        """

        header = {
            "namespace": "playbackSession",
            "command": "loadQueue",
            "sessionId": sid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        # Only send optional parameters if they have a value
        if metadata is not None:
            body["metadata"] = metadata
        if policies is not None:
            body["policies"] = policies

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def loadCloudQueue(self, queueBaseUrl=None, sid=None, httpAuthorization=None, useHttpAuthorizationForMedia=None, itemId=None, queueVersion=None, positionMillis=None, playOnCompletion=None, trackMetadata=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        One way to play audio on Sonos is by using a cloud queue, a list of tracks that you host on a server that the player can access. See Play audio for details. Use the loadCloudQueue command in the playbackSession namespace to load, and optionally start playback of, an item in a cloud queue.

        This command requires that your app has an open playback session with a cloud queue, created or joined using the createSession, joinSession, or joinOrCreateSession command.

        If you want to immediately start playing the track, set the playOnCompletion parameter to true. This bypasses the need to send a play command after the player loads the track. You should also send playback objects with information about the track in the trackMetadata parameter. This optimization improves the user experience by starting playback for the first track before the player fetches tracks from the cloud queue server.

        After receiving the loadCloudQueue command, the player will fetch a window of tracks from the cloud queue server centered around the item with the itemId that your app provided. If the track was deleted, the group will play the next track in the queue. For more details, see the Cloud Queue API /itemWindow endpoint.

        All commands in the playback and playbackMetadata namespace also apply to the cloud queue playback. For example, you can send the play or pause command in the playback namespace to play or pause a cloud queue track on a player.

        This method was autogenerated from the playbackSession namespace xml definition
        :param sid: (Required) Target session ID
        :param queueBaseUrl: (Required) The base URL for the cloud queue. The player uses this to form the REST URLs used to access the cloud queue. This URL is required to end in a recognized version specification indicating the version of the Cloud Queue API supported by the server. See the Cloud queue base URL and API version section in Play audio for details.

            You can pass RESTful segments within the base URL to identify the user. See the Communicate user identity in the base URL section in Play audio for details.
        :param httpAuthorization: (Optional) (Optional) The string value for the HTTP Authorization header, provided to the cloud queue server on all requests. See the Authorization for media and the cloud queue section in Play audio for details. If you dont include this value and the player matches the session to a SMAPI user account, the Authorization header will contain the SMAPI account OAuth token.
        :param useHttpAuthorizationForMedia: (Optional) (Optional) If true, the player passes the httpAuthorization token to HTTPS media requests associated with the cloud queue. The player never sends the token to insecure (HTTP) requests. This parameter has no bearing when cloud queue items reference SMAPI objects, in which case, the player sends normal SMAPI headers. The default value is false.
        :param itemId: (Optional) (Optional) The identifier for the track to load. If this is an empty string () or omitted, the player skips to the beginning of the cloud queue by requesting an item window with an empty string as the itemId. If you provide trackMetadata, you must also provide itemId, even if it is .
        :param queueVersion: (Optional) (Optional) An opaque identifier used to indicate the change state of the contents in the cloud queue. For example, if the list of tracks in the cloud queue changes, the cloud queue server would change the queueVersion. The player stores this value and can pass it back in the GET /itemWindow request. This enables your cloud-based client to keep its app and data model in sync across calls to the player.
        :param positionMillis: (Optional) (Optional) Position within the track in milliseconds. Default value is 0. If not provided and itemId matches the current item, the player does not interrupt playback or change the current position. The player still respects the playOnCompletion parameter, if provided. This value can be formatted as a JSON string or number.
        :param playOnCompletion: (Optional) (Optional) If true, start playback after loading the cloud queue. If you provided the  trackMetadata, the player begins playback immediately. If you provided the itemId, the player starts playing once the cloud queue window returns the metadata.

              If not provided, the default value is false. If false, the player loads the cloud queue, but requires the play command to begin.
        :param trackMetadata: (Optional) (Optional) The metadata for the first track. If provided, the player starts playing the item immediately, with the default playback policies, before the player retrieves the item window. See the track playback object type for the data structure of this object.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: groupCoordinatorChangedEvent globalErrorEvent
        """

        header = {
            "namespace": "playbackSession",
            "command": "loadCloudQueue",
            "sessionId": sid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if queueBaseUrl is None:
                missing_list.append('queueBaseUrl')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'queueBaseUrl': queueBaseUrl,
        }

        # Only send optional parameters if they have a value
        if httpAuthorization is not None:
            body["httpAuthorization"] = httpAuthorization
        if useHttpAuthorizationForMedia is not None:
            body["useHttpAuthorizationForMedia"] = useHttpAuthorizationForMedia
        if itemId is not None:
            body["itemId"] = itemId
        if queueVersion is not None:
            body["queueVersion"] = queueVersion
        if positionMillis is not None:
            body["positionMillis"] = positionMillis
        if playOnCompletion is not None:
            body["playOnCompletion"] = playOnCompletion
        if trackMetadata is not None:
            body["trackMetadata"] = trackMetadata

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def loadCloudQueueWithWindow(self, queueBaseUrl=None, itemId=None, window=None, sid=None, httpAuthorization=None, useHttpAuthorizationForMedia=None, positionMillis=None, playOnCompletion=None, bridgeContext=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Loads a Cloud Queue base URL into the playback session in preparation for playback. This variation allows the caller to provide the entire item window directly to the command, reducing the overhead of retrieving the item window from the Cloud Queue API. The player will still call GET /itemWindow on the Cloud Queue, but the server is free to return HTTP 304 (NOT MODIFIED) to indicate the player has the latest item window.

        This method was autogenerated from the playbackSession namespace xml definition
        :param sid: (Required) Target session ID
        :param queueBaseUrl: (Required) The base URL for the cloud queue. The player uses this to form the REST URLs used to access the cloud queue. This URL is required to end in a recognized version specification indicating the version of the Cloud Queue API supported by the server. See the Cloud queue base URL and API version section in Play audio for details.

            You can pass RESTful segments within the base URL to identify the user. See the Communicate user identity in the base URL section in Play audio for details.
        :param itemId: (Required) ID of the item in the queue at which to set the transport position.
        :param window: (Required) JSON object matching the response body of GET /itemWindow. This includes flags indicating the beginning or end of the queue, queue and context versions, and a list of up to 20 queue items.
        :param httpAuthorization: (Optional) (Optional) The string value for the HTTP Authorization header, provided to the cloud queue server on all requests. See the Authorization for media and the cloud queue section in Play audio for details. If you dont include this value and the player matches the session to a SMAPI user account, the Authorization header will contain the SMAPI account OAuth token.
        :param useHttpAuthorizationForMedia: (Optional) (Optional) If true, the player passes the httpAuthorization token to HTTPS media requests associated with the cloud queue. The player never sends the token to insecure (HTTP) requests. This parameter has no bearing when cloud queue items reference SMAPI objects, in which case, the player sends normal SMAPI headers. The default value is false.
        :param positionMillis: (Optional) (Optional) Position within the track in milliseconds. Default value is 0. If not provided and itemId matches the current item, the player does not interrupt playback or change the current position. The player still respects the playOnCompletion parameter, if provided. This value can be formatted as a JSON string or number.
        :param playOnCompletion: (Optional) (Optional) If true, start playback after loading the cloud queue. If you provided the  trackMetadata, the player begins playback immediately. If you provided the itemId, the player starts playing once the cloud queue window returns the metadata.

              If not provided, the default value is false. If false, the player loads the cloud queue, but requires the play command to begin.
        :param bridgeContext: (Optional) (Optional) Provides a means for our Voice Bridges to pass through a context (that is opaque to the player) such that it can be passed to the service back end by the player.
            See the bridgeContext type for a more detailed description on usage.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: groupCoordinatorChangedEvent globalErrorEvent
        """

        header = {
            "namespace": "playbackSession",
            "command": "loadCloudQueueWithWindow",
            "sessionId": sid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if queueBaseUrl is None:
                missing_list.append('queueBaseUrl')
            if itemId is None:
                missing_list.append('itemId')
            if window is None:
                missing_list.append('window')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'queueBaseUrl': queueBaseUrl,
            'itemId': itemId,
            'window': window,
        }

        # Only send optional parameters if they have a value
        if httpAuthorization is not None:
            body["httpAuthorization"] = httpAuthorization
        if useHttpAuthorizationForMedia is not None:
            body["useHttpAuthorizationForMedia"] = useHttpAuthorizationForMedia
        if positionMillis is not None:
            body["positionMillis"] = positionMillis
        if playOnCompletion is not None:
            body["playOnCompletion"] = playOnCompletion
        if bridgeContext is not None:
            body["bridgeContext"] = bridgeContext

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def loadStreamUrl(self, streamUrl=None, sid=None, playOnCompletion=None, stationMetadata=None, itemId=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        The loadStreamUrl command in the playbackSession namespace loads a streaming (live) radio station URL and optionally starts playback. Upon successful completion, the player sends a playbackStatus event to your app or hardware integration. Your app should subscribe to the playback namespace before sending the loadStreamUrl command to avoid race conditions in receiving playbackStatus or playbackError events.

        This command requires that your app has an open playback session with a cloud queue, created or joined using the createSession, joinSession, or joinOrCreateSession command.

        If you want to immediately start playing the stream, set the playOnCompletion parameter to true. This bypasses the need to send a play command after the player loads the stream.

        This method was autogenerated from the playbackSession namespace xml definition
        :param sid: (Required) Target session ID
        :param streamUrl: (Required) HTTP URL for the radio station stream. See the supported content types below. Note that you cannot use this command to send an on-demand track for playback.
        :param playOnCompletion: (Optional) (Optional) If true, the player will start playback after loading the stream URL. If false or not provided, the player remains in the PLAYBACK_IDLE state.
        :param stationMetadata: (Optional) (Optional) Metadata about the radio station. See below for details.
        :param itemId: (Optional) (Optional) If provided, the player includes this itemId in subsequent playbackStatus and playbackError events corresponding to this stream.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: groupCoordinatorChangedEvent globalErrorEvent
        """

        header = {
            "namespace": "playbackSession",
            "command": "loadStreamUrl",
            "sessionId": sid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if streamUrl is None:
                missing_list.append('streamUrl')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'streamUrl': streamUrl,
        }

        # Only send optional parameters if they have a value
        if playOnCompletion is not None:
            body["playOnCompletion"] = playOnCompletion
        if stationMetadata is not None:
            body["stationMetadata"] = stationMetadata
        if itemId is not None:
            body["itemId"] = itemId

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def loadStreamUrlWithContext(self, streamUrl=None, sid=None, playOnCompletion=None, stationMetadata=None, itemId=None, bridgeContext=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        A copy of loadStreamUrl with the addition of an additional context field that is needed by AVS (Alexa). See loadStreamUrl for details on other parameters.
        Note that this command should likely also be updated with any additions or changes to loadStreamUrl.

        This method was autogenerated from the playbackSession namespace xml definition
        :param sid: (Required) Target session ID
        :param streamUrl: (Required) HTTP URL for the radio station stream. See the supported content types below. Note that you cannot use this command to send an on-demand track for playback.
        :param playOnCompletion: (Optional) (Optional) If true, the player will start playback after loading the stream URL. If false or not provided, the player remains in the PLAYBACK_IDLE state.
        :param stationMetadata: (Optional) (Optional) Metadata about the radio station. See below for details.
        :param itemId: (Optional) (Optional) If provided, the player includes this itemId in subsequent playbackStatus and playbackError events corresponding to this stream.
        :param bridgeContext: (Optional) (Optional) Provides a means for our Voice Bridges to pass through a context (that is opaque to the player) such that it can be passed to the service back end by the player.
            See the bridgeContext type for a more detailed description on usage.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: groupCoordinatorChangedEvent globalErrorEvent
        """

        header = {
            "namespace": "playbackSession",
            "command": "loadStreamUrlWithContext",
            "sessionId": sid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if streamUrl is None:
                missing_list.append('streamUrl')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'streamUrl': streamUrl,
        }

        # Only send optional parameters if they have a value
        if playOnCompletion is not None:
            body["playOnCompletion"] = playOnCompletion
        if stationMetadata is not None:
            body["stationMetadata"] = stationMetadata
        if itemId is not None:
            body["itemId"] = itemId
        if bridgeContext is not None:
            body["bridgeContext"] = bridgeContext

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def refreshCloudQueue(self, sid=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use the refreshCloudQueue command in the playbackSession namespace to signal the player to re-fetch tracks from the cloud queue server centered around the current item. See the Cloud Queue API /itemWindow endpoint for details.

        This command requires your app to have either created a new session or joined an existing session, and also loaded a cloud queue on the group with loadCloudQueue.

        Your app should only use this command when it detects a change in the cloud queue content that should immediately be reflected in the group. For example, if a user removes the currently playing track with your app, use this command to remove the track from the group and stop it from playing. This helps provide a good user experience.

        This method was autogenerated from the playbackSession namespace xml definition
        :param sid: (Required) Target session ID
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: groupCoordinatorChangedEvent globalErrorEvent
        """

        header = {
            "namespace": "playbackSession",
            "command": "refreshCloudQueue",
            "sessionId": sid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def skipToItem(self, itemId=None, sid=None, queueVersion=None, positionMillis=None, playOnCompletion=None, trackMetadata=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use the skipToItem command in the playbackSession namespace to skip to the track with the specified itemId in a cloud queue and optionally seek and initiate playback. This command requires your app to have either created a new session or joined an existing session, and also loaded a cloud queue on the group with loadCloudQueue.

        Use playOnCompletion to start playing the cloud queue item being loaded, so your app doesnt have to send an extra play command.

        Most of the times your app already has access to the track metadata of the cloud queue item that is being loaded. Use the optional trackMetadata parameter to provide that information so the group can start playing the track immediately after receiving the loadCloudQueue command. This optimization improves the user experience by starting playback before the player fetches tracks from the cloud queue server.

        This method was autogenerated from the playbackSession namespace xml definition
        :param sid: (Required) Target session ID
        :param itemId: (Required) The identifier for the track. This is required, but does not need to be a value. If it is an empty string, the group will skip to the beginning of the queue.
        :param queueVersion: (Optional) (Optional) An opaque identifier used to indicate the change state of the contents in the cloud queue. For example, if the list of tracks in the cloud queue change, the cloud queue server would change the queueVersion. The player stores this value and can pass it back in the GET /itemWindow request.
        :param positionMillis: (Optional) (Optional) Position within track in milliseconds. If you omit this parameter and send a different itemId than the one that is currently playing, the player assumes that the positionMillis is zero. If you omit this parameter and send the itemId that is currently playing, the player does not change the position, and continues playing.
        :param playOnCompletion: (Optional) (Optional) Start playback after loading.
        :param trackMetadata: (Optional) (Optional) The target track to play. Entering this value enables the player to load and start playing the track immediately. See the track playback object for the data structure of this object.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: playbackErrorEvent groupCoordinatorChangedEvent globalErrorEvent
        """

        header = {
            "namespace": "playbackSession",
            "command": "skipToItem",
            "sessionId": sid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if itemId is None:
                missing_list.append('itemId')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'itemId': itemId,
        }

        # Only send optional parameters if they have a value
        if queueVersion is not None:
            body["queueVersion"] = queueVersion
        if positionMillis is not None:
            body["positionMillis"] = positionMillis
        if playOnCompletion is not None:
            body["playOnCompletion"] = playOnCompletion
        if trackMetadata is not None:
            body["trackMetadata"] = trackMetadata

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def skipToItemWithWindow(self, itemId=None, window=None, sid=None, positionMillis=None, playOnCompletion=None, bridgeContext=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Skips to the specified track at the given playback position and provides the item window as well. Upon successful completion, the player sends a playbackStatus event to the client. Playback errors are reflected as playbackError events.

        This method was autogenerated from the playbackSession namespace xml definition
        :param sid: (Required) Target session ID
        :param itemId: (Required) ID of the item in the queue at which to set the transport position. The same rules regarding playback interruption are applied. If itemId matches the currently playing item AND no positionMillis is supplied AND playOnCompletion is not set to false, playback continues without interruption.
        :param window: (Required) JSON object matching the response body of GET /itemWindow. This includes flags indicating the beginning or end of the queue, queue and context versions, and a list of up to 20 queue items.
        :param positionMillis: (Optional) (Optional) Position within track in milliseconds. If you omit this parameter and send a different itemId than the one that is currently playing, the player assumes that the positionMillis is zero. If you omit this parameter and send the itemId that is currently playing, the player does not change the position, and continues playing.
        :param playOnCompletion: (Optional) (Optional) Start playback after loading.
        :param bridgeContext: (Optional) (Optional) Provides a means for our Voice Bridges to pass through a context (that is opaque to the player) such that it can be passed to the service back end by the player.
            See the bridgeContext type for a more detailed description on usage.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: playbackErrorEvent groupCoordinatorChangedEvent globalErrorEvent
        """

        header = {
            "namespace": "playbackSession",
            "command": "skipToItemWithWindow",
            "sessionId": sid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if itemId is None:
                missing_list.append('itemId')
            if window is None:
                missing_list.append('window')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'itemId': itemId,
            'window': window,
        }

        # Only send optional parameters if they have a value
        if positionMillis is not None:
            body["positionMillis"] = positionMillis
        if playOnCompletion is not None:
            body["playOnCompletion"] = playOnCompletion
        if bridgeContext is not None:
            body["bridgeContext"] = bridgeContext

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def seek(self, itemId=None, positionMillis=None, sid=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use the seek command in the playbackSession namespace to seek to the position in the track with the specified itemId in a cloud queue. This command requires your app to have either created a new session or joined an existing session, and also loaded a cloud queue on the group with loadCloudQueue.

        Use itemId to ensure the group seeks on the current item. If the current items itemId does not match the one provided, the player returns an ERROR_INVALID_OBJECT_ID error.

        This method was autogenerated from the playbackSession namespace xml definition
        :param sid: (Required) Target session ID
        :param itemId: (Required) The identifier for the item. If this parameter does not match the currently playing item, the command fails. This ensures that playback does not jump back to a track if a user starts to scrub just as the player begins to play the next item.
        :param positionMillis: (Required) Position within track in milliseconds. If this value exceeds the current track duration time, Sonos moves to the end of the current track, which results in a skip to the next track.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: playbackErrorEvent groupCoordinatorChangedEvent globalErrorEvent
        """

        header = {
            "namespace": "playbackSession",
            "command": "seek",
            "sessionId": sid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if itemId is None:
                missing_list.append('itemId')
            if positionMillis is None:
                missing_list.append('positionMillis')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'itemId': itemId,
            'positionMillis': positionMillis,
        }

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def seekRelative(self, itemId=None, deltaMillis=None, sid=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use the seekRelative command in the playbackSession namespace to seek to the a relative position in the track with the specified cloud queue itemId.

        Use itemId to ensure the group seeks on the current item. If the current items itemId does not match the one provided, the player returns ERROR_INVALID_OBJECT_ID.

        This method was autogenerated from the playbackSession namespace xml definition
        :param sid: (Required) Target session ID
        :param itemId: (Required) (Optional) The identifier for the item. If this parameter does not match the currently playing item, the command fails. This ensures that playback does not jump back to a track if a user starts to scrub just as the player begins to play the next item.
        :param deltaMillis: (Required) Relative position within track in milliseconds. If this value exceeds the current track duration time, Sonos moves to the end of the current track, which results in a skip to the next track.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: playbackErrorEvent groupCoordinatorChangedEvent globalErrorEvent
        """

        header = {
            "namespace": "playbackSession",
            "command": "seekRelative",
            "sessionId": sid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if itemId is None:
                missing_list.append('itemId')
            if deltaMillis is None:
                missing_list.append('deltaMillis')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'itemId': itemId,
            'deltaMillis': deltaMillis,
        }

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]


# This class was automatically generated and should only be edited via namespace-client.py.template
class playerVolumeClient(object):
    """
    This namespace includes commands and events that enable your app to control and update player volume and player mute state.
    """

    def __init__(self, museWebsocketClient):
        self._museConnection = museWebsocketClient

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def subscribe(self, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use this command to subscribe to events in the playerVolume namespace.

        Returns an empty body with a success value of true if successful and sends a playerVolume event only for the subscriber.

        This method was autogenerated from the playerVolume namespace xml definition
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return:
        """

        header = {
            "namespace": "playerVolume",
            "command": "subscribe",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def unsubscribe(self, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use this command to unsubscribe to events in the playerVolume namespace.

        This method was autogenerated from the playerVolume namespace xml definition
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return:
        """

        header = {
            "namespace": "playerVolume",
            "command": "unsubscribe",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def setVolume(self, volume=None, muted=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use the setVolume command in the playerVolume namespace to set player volume and mute state.

        Returns an empty body with a success value of true if successful. The player generates a playerVolume event if the volume was changed.
        Additionally, if setVolume is called on a player that has a fixed player volume state that is true, the command will fail and you will receive an ERROR_COMMAND_FAILED globalError. This is because players with fixed volumes cannot be changed, for example, a CONNECT with fixed line out would respond with this error if your app tried to set the volume on it.

        This method was autogenerated from the playerVolume namespace xml definition
        :param volume: (Optional) (Optional) Between 0 and 100. If your app submits a number outside of this range, you will receive an ERROR_INVALID_PARAMETER error.
        :param muted: (Optional) (Optional) true to mute the player or false to unmute the player.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: globalErrorEvent
        """

        header = {
            "namespace": "playerVolume",
            "command": "setVolume",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        # Only send optional parameters if they have a value
        if volume is not None:
            body["volume"] = volume
        if muted is not None:
            body["muted"] = muted

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def setRelativeVolume(self, volumeDelta=None, muted=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use the setRelativeVolume command in the playerVolume namespace to increase or decrease volume for a player and unmute the player if muted.

        Returns an empty body with a success value of true if successful. The player generates a playerVolume event if the volume was changed.

        This method was autogenerated from the playerVolume namespace xml definition
        :param volumeDelta: (Optional) (Optional) Between -100 and 100 to indicate the amount to increase or decrease the volume for the player. If your app submits a number outside of this range, you will receive an ERROR_INVALID_PARAMETER error. The player adds this value to the current volume and keeps the result in the range of 0 to 100.
        :param muted: (Optional) (Optional) true to mute the player or false to unmute the player.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: globalErrorEvent
        """

        header = {
            "namespace": "playerVolume",
            "command": "setRelativeVolume",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        # Only send optional parameters if they have a value
        if volumeDelta is not None:
            body["volumeDelta"] = volumeDelta
        if muted is not None:
            body["muted"] = muted

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def setMute(self, muted=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use the setMute command in the playerVolume namespace to mute and unmute a player.

        Returns an empty body with a success value of true if successful. The player generates a playerVolume event if the mute state was changed.

        This method was autogenerated from the playerVolume namespace xml definition
        :param muted: (Required) true to mute the player or false to unmute the player.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: globalErrorEvent
        """

        header = {
            "namespace": "playerVolume",
            "command": "setMute",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if muted is None:
                missing_list.append('muted')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'muted': muted,
        }

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def getVolume(self, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use the getVolume command in the playerVolume namespace to get the volume and mute state of a player.

        This method was autogenerated from the playerVolume namespace xml definition
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: playerVolumeEvent
        """

        header = {
            "namespace": "playerVolume",
            "command": "getVolume",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def duck(self, durationMillis=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Ducking temporarily lowers the zone's volume without affecting the observed system volume. Sending another "duck" command to a system that is already ducking does not affect the output level. However, it does reset the duration.

        This method was autogenerated from the playerVolume namespace xml definition
        :param durationMillis: (Optional) Ducking lasts for the specified time, unless explicitly ended with the "unduck" command. The default value is 3 seconds when this value is omitted. The minimum value is 0 seconds. The maximum value is 60 seconds. Values outside the valid range are clamped.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return:
        """

        header = {
            "namespace": "playerVolume",
            "command": "duck",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        # Only send optional parameters if they have a value
        if durationMillis is not None:
            body["durationMillis"] = durationMillis

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def unduck(self, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        This command is the dual of duck. The volume is restored if there is a ducking operation in progress. Otherwise, the system accepts this command and does not change any internal state.

        This method was autogenerated from the playerVolume namespace xml definition
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return:
        """

        header = {
            "namespace": "playerVolume",
            "command": "unduck",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]


# This class was automatically generated and should only be edited via namespace-client.py.template
class playlistsClient(object):
    """
    The playlists namespace enables your app or hardware integration to enumerate the list of Sonos playlists in a household and load one to start playback.

    Listeners create Sonos playlists in the Sonos app. Sonos playlists can include tracks or playlists from multiple content services. The Sonos app displays playlists in a swimlane in My Sonos. It also adds favorited playlists to this swimlane.

    Note: As a best practice, use the favorites and playlists namespaces together if you use them. The Sonos app combines the results of these two namespaces in different swimlanes. If you dont use these together, users may think some of their content is missing in your integration.
    """

    def __init__(self, museWebsocketClient):
        self._museConnection = museWebsocketClient

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def subscribe(self, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use this command to subscribe to events in the playlists namespace.

        When subscribed, Sonos sends asynchronous versionChanged events when users update their Sonos playlists. Your app can then choose to fetch the playlists as needed whenever the version changes. This is because the playlistsList object can be large for asynchronous events.

        This method was autogenerated from the playlists namespace xml definition
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return:
        """

        header = {
            "namespace": "playlists",
            "command": "subscribe",
            "householdId": self._museConnection.hhid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def unsubscribe(self, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use this command to unsubscribe to events in the playlists namespace.

        This method was autogenerated from the playlists namespace xml definition
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return:
        """

        header = {
            "namespace": "playlists",
            "command": "unsubscribe",
            "householdId": self._museConnection.hhid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def getPlaylists(self, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use the getPlaylists command to get the list of Sonos playlists for a household. Playlists do not include pinned items (any non-playable containers pinned to My Sonos) or Sonos favorites. See the Save your favorites section in the Sonos user guide for details about My Sonos.

        Returns a playlistsList object, which is an array of playlist objects with a version number.

        This method was autogenerated from the playlists namespace xml definition
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: playlistsListEvent globalErrorEvent
        """

        header = {
            "namespace": "playlists",
            "command": "getPlaylists",
            "householdId": self._museConnection.hhid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def getPlaylist(self, playlistId=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        The getPlaylist command retrieves the track information associated with a particular playlist.

        This command returns a PlaylistSummary object, which contains an array of PlaylistTrack objects.

        This method was autogenerated from the playlists namespace xml definition
        :param playlistId: (Required) The identifier of the playlist. You can find this in the playlistsList object in the getPlaylists response.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: playlistSummaryEvent globalErrorEvent
        """

        header = {
            "namespace": "playlists",
            "command": "getPlaylist",
            "householdId": self._museConnection.hhid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if playlistId is None:
                missing_list.append('playlistId')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'playlistId': playlistId,
        }

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def postPlaylist(self, playlistId=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        This command retrieves the track information associated with a particular playlist.

        Returns a PlaylistSummary object which contains an array of PlaylistTrack objects. 

        NOTE: This endpoint is deprecated in version 1.18.1. Clients should prefer the "GET" version, getPlaylist.

        This method was autogenerated from the playlists namespace xml definition
        :param playlistId: (Required) The identifier of the playlist. You can find this in the playlistsList object in the getPlaylists response.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: playlistSummaryEvent globalErrorEvent
        """

        header = {
            "namespace": "playlists",
            "command": "postPlaylist",
            "householdId": self._museConnection.hhid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if playlistId is None:
                missing_list.append('playlistId')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'playlistId': playlistId,
        }

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def loadPlaylist(self, playlistId=None, action=None, playModes=None, playOnCompletion=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        The loadPlaylist command activates a playlist within the default playback session. This command interrupts any active private playback sessions. Sonos adds tracks from the playlist to the queue and activates the queue. This prevents your app from overwriting user-curated queues.

        This method was autogenerated from the playlists namespace xml definition
        :param playlistId: (Required) The identifier of the playlist. You can find this in the playlistsList object in the getPlaylists response.
        :param action: (Optional) (Optional) Controls how the the player inserts the playlist into the shared queue, such as APPEND, INSERT, INSERT_NEXT, or REPLACE. If omitted, defaults to append.
        :param playModes: (Optional) (Optional) Defines the functionality of one or more play modes. You can set these to customize shuffle, repeat, repeat-one and crossfade.
        :param playOnCompletion: (Optional) (Optional) If true, the player automatically starts playback. If false or not provided, the player remains in the PLAYBACK_IDLE state.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: groupCoordinatorChangedEvent globalErrorEvent
        """

        header = {
            "namespace": "playlists",
            "command": "loadPlaylist",
            "groupId": self._museConnection.getGroupId()
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if playlistId is None:
                missing_list.append('playlistId')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'playlistId': playlistId,
        }

        # Only send optional parameters if they have a value
        if action is not None:
            body["action"] = action
        if playModes is not None:
            body["playModes"] = playModes
        if playOnCompletion is not None:
            body["playOnCompletion"] = playOnCompletion

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]


# This class was automatically generated and should only be edited via namespace-client.py.template
class powerClient(object):
    """
    The power namespace enables you to interact with power-related functionality in supported devices.
    """

    def __init__(self, museWebsocketClient):
        self._museConnection = museWebsocketClient

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def setPowerPolicy(self, policy=None, durationSeconds=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        This command is used to ensure the standby timer on a player will not expire within the specified duration.

        This method was autogenerated from the power namespace xml definition
        :param policy: (Required)
        :param durationSeconds: (Required) The duration (in seconds) to potentially extend the standby timer.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: globalErrorEvent
        """

        header = {
            "namespace": "power",
            "command": "setPowerPolicy",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if policy is None:
                missing_list.append('policy')
            if durationSeconds is None:
                missing_list.append('durationSeconds')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'policy': policy,
            'durationSeconds': durationSeconds,
        }

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]


# This class was automatically generated and should only be edited via namespace-client.py.template
class recommendationClient(object):
    """
    Talks to the SmartPlay service to make sure that the group always has something to play.
    """

    def __init__(self, museWebsocketClient):
        self._museConnection = museWebsocketClient

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def getRecommendation(self, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Fetches a track to be played.

        This method was autogenerated from the recommendation namespace xml definition
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: recommendationResultsEvent globalErrorEvent
        """

        header = {
            "namespace": "recommendation",
            "command": "getRecommendation",
            "householdId": self._museConnection.hhid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]


# This class was automatically generated and should only be edited via namespace-client.py.template
class roomDetectionClient(object):
    """
    This namespace enables room detection operations with Chirp-capable devices on the local network.
    """

    def __init__(self, museWebsocketClient):
        self._museConnection = museWebsocketClient

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def startSignalling(self, channelNumber=None, durationSeconds=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        This operation begins the "chirp send" operation which tells the device
        to start sending out ultra-frequency signals that will be picked up by a receiving device.

        This method was autogenerated from the roomDetection namespace xml definition
        :param channelNumber: (Required) The chirp channel to signal on.
        :param durationSeconds: (Required) The chirp duration in seconds.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: chirpRequestEvent globalErrorEvent
        """

        header = {
            "namespace": "roomDetection",
            "command": "startSignalling",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if channelNumber is None:
                missing_list.append('channelNumber')
            if durationSeconds is None:
                missing_list.append('durationSeconds')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'channelNumber': channelNumber,
            'durationSeconds': durationSeconds,
        }

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def stopSignalling(self, playId=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        This operation begins the "chirp stop" operation which tells the device
        to stop sending out ultra-frequency signals that will be picked up by a receiving device.

        This method was autogenerated from the roomDetection namespace xml definition
        :param playId: (Required) ID of the Chirp playback to be stopped. This value was retrieved as part of calling startSignalling.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: globalErrorEvent
        """

        header = {
            "namespace": "roomDetection",
            "command": "stopSignalling",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if playId is None:
                missing_list.append('playId')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'playId': playId,
        }

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]


# This class was automatically generated and should only be edited via namespace-client.py.template
class settingsClient(object):
    """
    The settings namespace includes commands to change settings on Sonos players. This namespace does not meet the
    quality bar for Sonos. It needs a significant overhaul before the functionality can be shared with partners.

    A unique identifier for this setting within the provided namespaces. The namespaces
    can be used as a filter to select a subset of settings in the getSettings call.

    Examples
    =====

    All Current Settings:

    GET /api/users/{userId}/settings
    --------------------------
    {
      "animals" : {
        "catsAllowed": {
          "value": true
        }
        "dogsAllowed": {
          "value": false
        }
      },
      "store": {
        "name": {
          "value": "Acme Petstore"
        }
      },
      "playback": {
        "spotifyAdaptiveBitRate": {
          "value": {
            "enable": true,
            "timeoutMinutes": 120
          }
        }
      }
    }

    Call to getSettings where the namespace filter is "animals":
    GET /api/users/{userId}/settings?namespaces=animals
    --------------------------
    {
      "animals": {
        "catsAllowed": {
          "value": true
        }
        "dogsAllowed": {
          "value": false,
          "scheduledChangeAt": "2020-12-09T00:00.000Z"
          "scheduledChangeValue": true
        }
      }
    }
    """

    def __init__(self, museWebsocketClient):
        self._museConnection = museWebsocketClient

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def subscribe(self, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use this command to subscribe to events in the settings namespace.
          Events are emitted only when cloud settings data have changed.
          Other settings (player, public, protected, restricted, true play, microphone)
          do not emit events and will be migrated to cloud settings.

        This method was autogenerated from the settings namespace xml definition
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return:
        """

        header = {
            "namespace": "settings",
            "command": "subscribe",
            "userId": self._museConnection.userId
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def unsubscribe(self, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use this command to unsubscribe to events in the settings namespace.
          Events are emitted only when cloud settings data have changed.
          Other settings (player, public, protected, restricted, true play, microphone)
          do not emit events and will be migrated to cloud settings.

        This method was autogenerated from the settings namespace xml definition
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return:
        """

        header = {
            "namespace": "settings",
            "command": "unsubscribe",
            "userId": self._museConnection.userId
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def getSettings(self, namespaces=None, targetSettingsOnly=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Fetches a list of user settings from the settings service.

        Note:
        ===
        Currently only user-targeted settings are supported, but in the future
        this command will support other targets. (e.g. householdId, playerId,
        userId, etc.)

        This method was autogenerated from the settings namespace xml definition
        :param namespaces: (Optional) Optionally, an array of namespaces can be specified to return
            a filtered view of the settings.
        :param targetSettingsOnly: (Optional) By default, getSettings will combine results from the entire object
            hierarchy. If the desire is to only fetch settings directly applied
            to a player or household, setting "targetSettingsOnly=true" will
            prevent traversal.0
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: settingsEvent globalErrorEvent
        """

        header = {
            "namespace": "settings",
            "command": "getSettings",
            "userId": self._museConnection.userId
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        # Only send optional parameters if they have a value
        if namespaces is not None:
            body["namespaces"] = namespaces
        if targetSettingsOnly is not None:
            body["targetSettingsOnly"] = targetSettingsOnly

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def setSettings(self, oauthToken=None, _global=None, playback=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Updates user settings by pushing the given list of settings to the
        settings service.

        Returning a setting to its default value effectively deletes
        the setting from storage. Default values, where there is no
        scheduled change, will not be returned.

        Note:
        ===
        Currently only user-targeted settings are supported, but in the future
        this command will support other targets. (e.g. householdId, playerId,
        userId, etc.)

        This method was autogenerated from the settings namespace xml definition
        :param global: (Optional) Settings for the global namespace.
        :param playback: (Optional) Settings for the playback namespace.
        :param oauthToken: (Required) HH_CONFIG_ADMIN scoped oauth token
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: settingsEvent globalErrorEvent
        """

        header = {
            "namespace": "settings",
            "command": "setSettings",
            "userId": self._museConnection.userId
        }

        oauthToken = self._museConnection.hhConfigAdminToken if oauthToken is None else oauthToken
        # Verified required oauthToken param is not None
        assert oauthToken is not None, "Command requires an oauthToken param"
        header["authorization"] = "bearer {}".format(oauthToken)
        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        # Only send optional parameters if they have a value
        if _global is not None:
            body["global"] = _global
        if playback is not None:
            body["playback"] = playback

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def getPlayerSettings(self, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Get player settings such as volumeMode, wifiDisable, and other settings. See the playerSettings type for details.

        This method was autogenerated from the settings namespace xml definition
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: playerSettingsEvent globalErrorEvent
        """

        header = {
            "namespace": "settings",
            "command": "getPlayerSettings",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def setPlayerSettings(self, oauthToken=None, volumeMode=None, volumeScalingFactor=None, monoMode=None, wifiDisable=None, voice=None, batteryUsagePolicy=None, networkingMode=None, selfTruePlay=None, lineIn=None, homeTheater=None, eq=None, anc=None, guidance=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Set player settings such as volumeMode, wifiDisable, and other settings. See the playerSettings type for details.

        This command can be used to set multiple values at once. The command returns ERROR_NO_PERMISSION (http code 403) when
        the provided token does not possess a sufficient scope.

        This method was autogenerated from the settings namespace xml definition
        :param volumeMode: (Optional) VARIABLE: the normal mode. The player enables volume controls and makes volume adjustments internally.
            FIXED: disables volume controls. The player always outputs a fixed volume. This mode is useful for devices without a built-in amplifier, like the Sonos Connect.
            PASS_THROUGH: enables volume controls in fixed output mode. When enabled, the player emits volume changes as playerVolume events, just as it would in the normal mode. However, the player doesnt modify the audio signal. This currently works on the Sonos Amp and the Connect.
        :param volumeScalingFactor: (Optional) A scaling factor between 0.01 (1%) and 1.0 (100%) applied to compute the volume level. When set, this factor applies to each logical player. Only the primary player accepts this value. For example, the left speaker in a bonded pair or the main home theater speaker, such as the Playbar, in a 5.1 surround set.
        :param monoMode: (Optional) When true, enables mono mode on supported devices. The Sonos Amp supports this setting when it is not powering surrounds as part of a home theater setup.
        :param wifiDisable: (Optional) When true, disables the wireless radio for the device if it detects a valid Ethernet carrier.
        :param voice: (Optional) Toggles features for Sonos speakers with microphones.         
            Acceptable voice settings consist of a confirmationTone or allowMicrophone.
        :param batteryUsagePolicy: (Optional) Sets the usage policy for the battery on a Sonos device.
            Acceptable values are ALWAYS_READY, NORMAL, BATTERY_SAVER.
        :param networkingMode: (Optional) Sets the networking mode on a Sonos device.
            Acceptable values are BLUETOOTH or WIFI.
        :param selfTruePlay: (Optional)
        :param lineIn: (Optional)
        :param homeTheater: (Optional)
        :param eq: (Optional)
        :param anc: (Optional)
        :param guidance: (Optional)
        :param oauthToken: (Required) HH_CONFIG scoped oauth token
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: globalErrorEvent
        """

        header = {
            "namespace": "settings",
            "command": "setPlayerSettings",
            "playerId": self._museConnection.uuid
        }

        oauthToken = self._museConnection.hhConfigToken if oauthToken is None else oauthToken
        # Verified required oauthToken param is not None
        assert oauthToken is not None, "Command requires an oauthToken param"
        header["authorization"] = "bearer {}".format(oauthToken)
        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        # Only send optional parameters if they have a value
        if volumeMode is not None:
            body["volumeMode"] = volumeMode
        if volumeScalingFactor is not None:
            body["volumeScalingFactor"] = volumeScalingFactor
        if monoMode is not None:
            body["monoMode"] = monoMode
        if wifiDisable is not None:
            body["wifiDisable"] = wifiDisable
        if voice is not None:
            body["voice"] = voice
        if batteryUsagePolicy is not None:
            body["batteryUsagePolicy"] = batteryUsagePolicy
        if networkingMode is not None:
            body["networkingMode"] = networkingMode
        if selfTruePlay is not None:
            body["selfTruePlay"] = selfTruePlay
        if lineIn is not None:
            body["lineIn"] = lineIn
        if homeTheater is not None:
            body["homeTheater"] = homeTheater
        if eq is not None:
            body["eq"] = eq
        if anc is not None:
            body["anc"] = anc
        if guidance is not None:
            body["guidance"] = guidance

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def setAllowMicrophone(self, allowMicrophone=None, oauthToken=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Enables or disables the microphone.

        This method was autogenerated from the settings namespace xml definition
        :param allowMicrophone: (Required)
        :param oauthToken: (Required) HH_CONFIG_ADMIN scoped oauth token
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: globalErrorEvent
        """

        header = {
            "namespace": "settings",
            "command": "setAllowMicrophone",
            "playerId": self._museConnection.uuid
        }

        oauthToken = self._museConnection.hhConfigAdminToken if oauthToken is None else oauthToken
        # Verified required oauthToken param is not None
        assert oauthToken is not None, "Command requires an oauthToken param"
        header["authorization"] = "bearer {}".format(oauthToken)
        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if allowMicrophone is None:
                missing_list.append('allowMicrophone')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'allowMicrophone': allowMicrophone,
        }

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def setSelfTruePlay(self, selfTruePlay=None, oauthToken=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Enables or disables Trueplay.

        This method was autogenerated from the settings namespace xml definition
        :param selfTruePlay: (Required)
        :param oauthToken: (Required) HH_CONFIG_ADMIN scoped oauth token
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: globalErrorEvent
        """

        header = {
            "namespace": "settings",
            "command": "setSelfTruePlay",
            "playerId": self._museConnection.uuid
        }

        oauthToken = self._museConnection.hhConfigAdminToken if oauthToken is None else oauthToken
        # Verified required oauthToken param is not None
        assert oauthToken is not None, "Command requires an oauthToken param"
        header["authorization"] = "bearer {}".format(oauthToken)
        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if selfTruePlay is None:
                missing_list.append('selfTruePlay')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'selfTruePlay': selfTruePlay,
        }

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def getRestrictedAdminSettings(self, setting=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Get "restricted-admin" settings.

        This method was autogenerated from the settings namespace xml definition
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: restrictedAdminSettingsEvent
        """

        header = {
            "namespace": "settings",
            "command": "getRestrictedAdminSettings",
            "householdId": self._museConnection.hhid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if setting is None:
                missing_list.append('setting')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'setting': setting,
        }

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def setRestrictedAdminSettings(self, oauthToken=None, explicitContentFiltering=None, userMetricsTracking=None, recentlyPlayed=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Set "restricted-admin" settings.

        This method was autogenerated from the settings namespace xml definition
        :param explicitContentFiltering: (Optional)
        :param userMetricsTracking: (Optional)
        :param recentlyPlayed: (Optional)
        :param oauthToken: (Required) HH_CONFIG_ADMIN scoped oauth token
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return:
        """

        header = {
            "namespace": "settings",
            "command": "setRestrictedAdminSettings",
            "householdId": self._museConnection.hhid
        }

        oauthToken = self._museConnection.hhConfigAdminToken if oauthToken is None else oauthToken
        # Verified required oauthToken param is not None
        assert oauthToken is not None, "Command requires an oauthToken param"
        header["authorization"] = "bearer {}".format(oauthToken)
        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        # Only send optional parameters if they have a value
        if explicitContentFiltering is not None:
            body["explicitContentFiltering"] = explicitContentFiltering
        if userMetricsTracking is not None:
            body["userMetricsTracking"] = userMetricsTracking
        if recentlyPlayed is not None:
            body["recentlyPlayed"] = recentlyPlayed

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def getPublicSettings(self, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Get "public" settings.

        This method was autogenerated from the settings namespace xml definition
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: publicSettingsEvent globalErrorEvent
        """

        header = {
            "namespace": "settings",
            "command": "getPublicSettings",
            "householdId": self._museConnection.hhid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def getProtectedAdminSettings(self, oauthToken=None, setting=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Get "protected-admin" settings.

        This method was autogenerated from the settings namespace xml definition
        :param setting: (Optional) Optionally specifies a single setting within the protected-admin
            settings category to retrieve. When included, other settings will
            not be included in the response.
        :param oauthToken: (Required) HH_CONFIG_ADMIN scoped oauth token
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: protectedAdminSettingsEvent sonosnetEvent networksListEvent offlinePskEvent globalErrorEvent
        """

        header = {
            "namespace": "settings",
            "command": "getProtectedAdminSettings",
            "householdId": self._museConnection.hhid
        }

        oauthToken = self._museConnection.hhConfigAdminToken if oauthToken is None else oauthToken
        # Verified required oauthToken param is not None
        assert oauthToken is not None, "Command requires an oauthToken param"
        header["authorization"] = "bearer {}".format(oauthToken)
        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        # Only send optional parameters if they have a value
        if setting is not None:
            body["setting"] = setting

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def setProtectedAdminSettings(self, oauthToken=None, sonosnet=None, networks=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Set "protected-admin" settings.

        This method was autogenerated from the settings namespace xml definition
        :param sonosnet: (Optional) Updates SonosNet settings. Requests that set the SonosNet key will be rejected.
        :param networks: (Optional) Updates the list credentials for known wireless networks. Setting the
            list here replaces any existing list in the household. Requests that
            include the same SSID multiple times will be rejected.
        :param oauthToken: (Required) HH_CONFIG_ADMIN scoped oauth token
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: globalErrorEvent
        """

        header = {
            "namespace": "settings",
            "command": "setProtectedAdminSettings",
            "householdId": self._museConnection.hhid
        }

        oauthToken = self._museConnection.hhConfigAdminToken if oauthToken is None else oauthToken
        # Verified required oauthToken param is not None
        assert oauthToken is not None, "Command requires an oauthToken param"
        header["authorization"] = "bearer {}".format(oauthToken)
        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        # Only send optional parameters if they have a value
        if sonosnet is not None:
            body["sonosnet"] = sonosnet
        if networks is not None:
            body["networks"] = networks

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]


# This class was automatically generated and should only be edited via namespace-client.py.template
class soundSwapClient(object):
    """
    This namespace enables Sonos Sound Swap operations between players on the local network.
    It contains operations to perform Music Swap.
    """

    def __init__(self, museWebsocketClient):
        self._museConnection = museWebsocketClient

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def triggerSwap(self, playerId=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        This command is used to trigger a swap operation on a Portable device. The caller can optionally
        specify a target, but if none is specified the target player will be determined using Room Detection.

        This method was autogenerated from the soundSwap namespace xml definition
        :param playerId: (Optional) The optional target player to swap audio content with.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: globalErrorEvent
        """

        header = {
            "namespace": "soundSwap",
            "command": "triggerSwap",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        # Only send optional parameters if they have a value
        if playerId is not None:
            body["playerId"] = playerId

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def requestSwap(self, playbackState=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        This command is sent from a swap initiator to its target to request swap. The playbackState indicates the most current
        state of the initiator. The target response will indicate whether the request has been accepted and if so whatever
        information the initiator needs to complete the process.

        This method was autogenerated from the soundSwap namespace xml definition
        :param playbackState: (Required) The playback state of the initiator. PLAYBACK_STATE_PLAYING indicates that the desired behavior is music push.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: soundSwapRequestResponseEvent globalErrorEvent
        """

        header = {
            "namespace": "soundSwap",
            "command": "requestSwap",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if playbackState is None:
                missing_list.append('playbackState')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'playbackState': playbackState,
        }

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]


# This class was automatically generated and should only be edited via namespace-client.py.template
class topologyClient(object):
    """
    This namespace is deprecated. Only of the commands were removed, but the namespace is still
    used to send cloudRegistrationStatus events to Lechmere.
    """

    def __init__(self, museWebsocketClient):
        self._museConnection = museWebsocketClient


# This class was automatically generated and should only be edited via namespace-client.py.template
class trueplayClient(object):
    """
    The trueplay namespace contains commands that can be used by clients to perform Trueplay
    and Trueplay-related actions like speaker detection.
    """

    def __init__(self, museWebsocketClient):
        self._museConnection = museWebsocketClient

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def detectSpeakers(self, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Detect Sonance speakers connected to a Sonos Amp.  To run detection, device must be
        in "speaker-detect" config mode.  The config mode must persist outside of the command
        such that TV is not autoplayed in the interval between this commands completion and the
        user initiating Trueplay.

        This method was autogenerated from the trueplay namespace xml definition
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: speakerDetectionStatusEvent globalErrorEvent
        """

        header = {
            "namespace": "trueplay",
            "command": "detectSpeakers",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def getConfiguration(self, id=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Access a previous uploaded TruePlay configuration associated with the associated id. See "setConfiguration".

        This method was autogenerated from the trueplay namespace xml definition
        :param id: (Required) The id of the configuration to access. This command returns an empty object if a matching configuration
            is not found.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: trueplayConfigurationEvent
        """

        header = {
            "namespace": "trueplay",
            "command": "getConfiguration",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if id is None:
                missing_list.append('id')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'id': id,
        }

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def setConfiguration(self, id=None, trueplayConfig=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Set a TruePlay configuration. If configuration with matching id is not found, create it. Otherwise update
        the existing configuration.

        This method was autogenerated from the trueplay namespace xml definition
        :param id: (Required) Specify the id of the configuration to set.
        :param trueplayConfig: (Required) A new TrueplayConfiguration that gets uploaded.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: trueplayConfigurationEvent
        """

        header = {
            "namespace": "trueplay",
            "command": "setConfiguration",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if id is None:
                missing_list.append('id')
            if trueplayConfig is None:
                missing_list.append('trueplayConfig')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'id': id,
            'trueplayConfig': trueplayConfig,
        }

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]


# This class was automatically generated and should only be edited via namespace-client.py.template
class upnpAVTransportClient(object):
    """
    Sonos was originally built around UPnP, which is a technology designed before the advent
    of cloud computing. UPnP does a lot of things well, but a fundamental design flaw is that
    UPnP trusts the local area network. Additionally, the use of XML and SOAP has fallen out
    of favor. As a result, Sonos decided to move onto a new control API nicknamed muse. Muse
    is built on REST, WebSocket, and JSON technology. It has been designed with security and
    cloud requirements. The time has come for Sonos to transition away from UPnP. However, the
    muse stack is not as broad as the UPnP stack.

    This private namespace is used to execute UPnP commands over a muse transport. Thus, Sonos
    can transition the controller to a modern transport. This plan is
    more expedient than implementing all of the UPnP functionality in muse _and_ changing the
    controller to use muse commands wholesale. This intermediate transition plan allows Sonos
    to maintain all of the controller business logic while changing the transport layer.

    The namespace is only available on the LAN, because UPnP is only used on the LAN. Muse v2
    is scheduled for the early part of 2020. The updated protocol will require tokens
    for every command on the LAN and incorporate the new identity backend.

    At this time, UPnP events are delivered via the traditional UPnP post-back URL. This decision
    was made to limit controller impact. Delivering muse events requires a persistent WebSocket
    connection today, which is outside of the initial scope.

    This namespace exposes the UPnP AVTransport1 service. We are providing specific namespaces
    per service in order to limit security access to different functionality.
    """

    def __init__(self, museWebsocketClient):
        self._museConnection = museWebsocketClient

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def call(self, method=None, headers=None, input=None, output=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use this command to execute a single UPnP command on the local player.

        This method was autogenerated from the upnpAVTransport namespace xml definition
        :param method: (Required) This is the UPnP method name.
        :param headers: (Optional) Custom headers to add to the UPnP command. The product code imposes a maximum bytes size, rather
            than a maximum number of headers. Six seems like a good starting point.

            The headers should be added as name / value pairs: "X-Sonos-Header-Name: Header Value"
        :param input: (Optional) UPnP input parameters.
        :param output: (Optional) UPnP output parameter names.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: upnpResponseEvent
        """

        header = {
            "namespace": "upnpAVTransport",
            "command": "call",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if method is None:
                missing_list.append('method')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'method': method,
        }

        # Only send optional parameters if they have a value
        if headers is not None:
            body["headers"] = headers
        if input is not None:
            body["input"] = input
        if output is not None:
            body["output"] = output

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def subscribe(self, durationSecs=None, port=None, eventPath=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        UPnP clients use this interface to request event notifications. The UPnP events are
        delivered out of band, using the traditional UPnP path. The parameters set the TCP
        port and HTTP URI path on which the client wants notifications. The IP address is
        inferred from the incoming connection.

        This method was autogenerated from the upnpAVTransport namespace xml definition
        :param durationSecs: (Optional) This is desired the subscription duration in seconds. The player may override this
            value, in which case the actual duration is returned in the response.
        :param port: (Optional) This is the TCP port on which the client is hosting the HTTP service where
            UPnP notifications should be posted. Required when subscribing over REST.
        :param eventPath: (Optional) This is the URL path where the player posts UPnP notifications. The complete URL
            is formed by combining the client IP address, the port parameter and this path.
            This parameter is required when subscribing over REST.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: upnpResponseEvent
        """

        header = {
            "namespace": "upnpAVTransport",
            "command": "subscribe",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        # Only send optional parameters if they have a value
        if durationSecs is not None:
            body["durationSecs"] = durationSecs
        if port is not None:
            body["port"] = port
        if eventPath is not None:
            body["eventPath"] = eventPath

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def renew(self, logicalSID=None, durationSecs=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        This interface is used to refresh subscriptions.

        This method was autogenerated from the upnpAVTransport namespace xml definition
        :param logicalSID: (Required) This parameter identifies the subscription to renew. It is the value returned from
            the subscribe command.
        :param durationSecs: (Optional) This is desired the subscription duration in seconds. The player may override this
            value, in which case the actual duration is returned in the response.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: upnpResponseEvent
        """

        header = {
            "namespace": "upnpAVTransport",
            "command": "renew",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if logicalSID is None:
                missing_list.append('logicalSID')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'logicalSID': logicalSID,
        }

        # Only send optional parameters if they have a value
        if durationSecs is not None:
            body["durationSecs"] = durationSecs

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def unsubscribe(self, logicalSID=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use this interface to cancel a subscription. The server will stop posting events
        after processing this command.

        This method was autogenerated from the upnpAVTransport namespace xml definition
        :param logicalSID: (Required) This parameter identifies the subscription to cancel. It is the value returned from
            the subscribe command.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: upnpResponseEvent
        """

        header = {
            "namespace": "upnpAVTransport",
            "command": "unsubscribe",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if logicalSID is None:
                missing_list.append('logicalSID')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'logicalSID': logicalSID,
        }

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]


# This class was automatically generated and should only be edited via namespace-client.py.template
class upnpAlarmClockClient(object):
    """
    Sonos was originally built around UPnP, which is a technology designed before the advent
    of cloud computing. UPnP does a lot of things well, but a fundamental design flaw is that
    UPnP trusts the local area network. Additionally, the use of XML and SOAP has fallen out
    of favor. As a result, Sonos decided to move onto a new control API nicknamed muse. Muse
    is built on REST, WebSocket, and JSON technology. It has been designed with security and
    cloud requirements. The time has come for Sonos to transition away from UPnP. However, the
    muse stack is not as broad as the UPnP stack.

    This private namespace is used to execute UPnP commands over a muse transport. Thus, Sonos
    can transition the controller to a modern transport. This plan is
    more expedient than implementing all of the UPnP functionality in muse _and_ changing the
    controller to use muse commands wholesale. This intermediate transition plan allows Sonos
    to maintain all of the controller business logic while changing the transport layer.

    The namespace is only available on the LAN, because UPnP is only used on the LAN. Muse v2
    is scheduled for the early part of 2020. The updated protocol will require tokens
    for every command on the LAN and incorporate the new identity backend.

    At this time, UPnP events are delivered via the traditional UPnP post-back URL. This decision
    was made to limit controller impact. Delivering muse events requires a persistent WebSocket
    connection today, which is outside of the initial scope.

    This namespace exposes the UPnP AlarmClock1 service. We are providing specific namespaces
    per service in order to limit security access to different functionality.
    """

    def __init__(self, museWebsocketClient):
        self._museConnection = museWebsocketClient

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def call(self, method=None, headers=None, input=None, output=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use this command to execute a single UPnP command on the local player.

        This method was autogenerated from the upnpAlarmClock namespace xml definition
        :param method: (Required) This is the UPnP method name.
        :param headers: (Optional) Custom headers to add to the UPnP command. The product code imposes a maximum bytes size, rather
            than a maximum number of headers. Six seems like a good starting point.

            The headers should be added as name / value pairs: "X-Sonos-Header-Name: Header Value"
        :param input: (Optional) UPnP input parameters.
        :param output: (Optional) UPnP output parameter names.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: upnpResponseEvent
        """

        header = {
            "namespace": "upnpAlarmClock",
            "command": "call",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if method is None:
                missing_list.append('method')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'method': method,
        }

        # Only send optional parameters if they have a value
        if headers is not None:
            body["headers"] = headers
        if input is not None:
            body["input"] = input
        if output is not None:
            body["output"] = output

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def subscribe(self, durationSecs=None, port=None, eventPath=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        UPnP clients use this interface to request event notifications. The UPnP events are
        delivered out of band, using the traditional UPnP path. The parameters set the TCP
        port and HTTP URI path on which the client wants notifications. The IP address is
        inferred from the incoming connection.

        This method was autogenerated from the upnpAlarmClock namespace xml definition
        :param durationSecs: (Optional) This is desired the subscription duration in seconds. The player may override this
            value, in which case the actual duration is returned in the response.
        :param port: (Optional) This is the TCP port on which the client is hosting the HTTP service where
            UPnP notifications should be posted. Required when subscribing over REST.
        :param eventPath: (Optional) This is the URL path where the player posts UPnP notifications. The complete URL
            is formed by combining the client IP address, the port parameter and this path.
	          This parameter is required when subscribing over REST.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: upnpResponseEvent
        """

        header = {
            "namespace": "upnpAlarmClock",
            "command": "subscribe",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        # Only send optional parameters if they have a value
        if durationSecs is not None:
            body["durationSecs"] = durationSecs
        if port is not None:
            body["port"] = port
        if eventPath is not None:
            body["eventPath"] = eventPath

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def renew(self, logicalSID=None, durationSecs=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        This interface is used to refresh subscriptions.

        This method was autogenerated from the upnpAlarmClock namespace xml definition
        :param logicalSID: (Required) This parameter identifies the subscription to renew. It is the value returned from
            the subscribe command.
        :param durationSecs: (Optional) This is desired the subscription duration in seconds. The player may override this
            value, in which case the actual duration is returned in the response.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: upnpResponseEvent
        """

        header = {
            "namespace": "upnpAlarmClock",
            "command": "renew",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if logicalSID is None:
                missing_list.append('logicalSID')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'logicalSID': logicalSID,
        }

        # Only send optional parameters if they have a value
        if durationSecs is not None:
            body["durationSecs"] = durationSecs

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def unsubscribe(self, logicalSID=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use this interface to cancel a subscription. The server will stop posting events
        after processing this command.

        This method was autogenerated from the upnpAlarmClock namespace xml definition
        :param logicalSID: (Required) This parameter identifies the subscription to cancel. It is the value returned from
            the subscribe command.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: upnpResponseEvent
        """

        header = {
            "namespace": "upnpAlarmClock",
            "command": "unsubscribe",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if logicalSID is None:
                missing_list.append('logicalSID')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'logicalSID': logicalSID,
        }

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]


# This class was automatically generated and should only be edited via namespace-client.py.template
class upnpAudioInClient(object):
    """
    Sonos was originally built around UPnP, which is a technology designed before the advent
    of cloud computing. UPnP does a lot of things well, but a fundamental design flaw is that
    UPnP trusts the local area network. Additionally, the use of XML and SOAP has fallen out
    of favor. As a result, Sonos decided to move onto a new control API nicknamed muse. Muse
    is built on REST, WebSocket, and JSON technology. It has been designed with security and
    cloud requirements. The time has come for Sonos to transition away from UPnP. However, the
    muse stack is not as broad as the UPnP stack.

    This private namespace is used to execute UPnP commands over a muse transport. Thus, Sonos
    can transition the controller to a modern transport. This plan is
    more expedient than implementing all of the UPnP functionality in muse _and_ changing the
    controller to use muse commands wholesale. This intermediate transition plan allows Sonos
    to maintain all of the controller business logic while changing the transport layer.

    The namespace is only available on the LAN, because UPnP is only used on the LAN. Muse v2
    is scheduled for the early part of 2020. The updated protocol will require tokens
    for every command on the LAN and incorporate the new identity backend.

    At this time, UPnP events are delivered via the traditional UPnP post-back URL. This decision
    was made to limit controller impact. Delivering muse events requires a persistent WebSocket
    connection today, which is outside of the initial scope.

    This namespace exposes the UPnP AudioIn service. We are providing specific namespaces
    per service in order to limit security access to different functionality.
    """

    def __init__(self, museWebsocketClient):
        self._museConnection = museWebsocketClient

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def call(self, method=None, headers=None, input=None, output=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use this command to execute a single UPnP command on the local player.

        This method was autogenerated from the upnpAudioIn namespace xml definition
        :param method: (Required) This is the UPnP method name.
        :param headers: (Optional) Custom headers to add to the UPnP command. The product code imposes a maximum bytes size, rather
            than a maximum number of headers. Six seems like a good starting point.

            The headers should be added as name / value pairs: "X-Sonos-Header-Name: Header Value"
        :param input: (Optional) UPnP input parameters.
        :param output: (Optional) UPnP output parameter names.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: upnpResponseEvent
        """

        header = {
            "namespace": "upnpAudioIn",
            "command": "call",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if method is None:
                missing_list.append('method')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'method': method,
        }

        # Only send optional parameters if they have a value
        if headers is not None:
            body["headers"] = headers
        if input is not None:
            body["input"] = input
        if output is not None:
            body["output"] = output

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def subscribe(self, durationSecs=None, port=None, eventPath=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        UPnP clients use this interface to request event notifications. The UPnP events are
        delivered out of band, using the traditional UPnP path. The parameters set the TCP
        port and HTTP URI path on which the client wants notifications. The IP address is
        inferred from the incoming connection.

        This method was autogenerated from the upnpAudioIn namespace xml definition
        :param durationSecs: (Optional) This is desired the subscription duration in seconds. The player may override this
            value, in which case the actual duration is returned in the response.
        :param port: (Optional) This is the TCP port on which the client is hosting the HTTP service where
            UPnP notifications should be posted. Required when subscribing over REST.
        :param eventPath: (Optional) This is the URL path where the player posts UPnP notifications. The complete URL
            is formed by combining the client IP address, the port parameter and this path.
            This parameter is required when subscribing over REST.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: upnpResponseEvent
        """

        header = {
            "namespace": "upnpAudioIn",
            "command": "subscribe",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        # Only send optional parameters if they have a value
        if durationSecs is not None:
            body["durationSecs"] = durationSecs
        if port is not None:
            body["port"] = port
        if eventPath is not None:
            body["eventPath"] = eventPath

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def renew(self, logicalSID=None, durationSecs=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        This interface is used to refresh subscriptions.

        This method was autogenerated from the upnpAudioIn namespace xml definition
        :param logicalSID: (Required) This parameter identifies the subscription to renew. It is the value returned from
            the subscribe command.
        :param durationSecs: (Optional) This is desired the subscription duration in seconds. The player may override this
            value, in which case the actual duration is returned in the response.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: upnpResponseEvent
        """

        header = {
            "namespace": "upnpAudioIn",
            "command": "renew",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if logicalSID is None:
                missing_list.append('logicalSID')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'logicalSID': logicalSID,
        }

        # Only send optional parameters if they have a value
        if durationSecs is not None:
            body["durationSecs"] = durationSecs

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def unsubscribe(self, logicalSID=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use this interface to cancel a subscription. The server will stop posting events
        after processing this command.

        This method was autogenerated from the upnpAudioIn namespace xml definition
        :param logicalSID: (Required) This parameter identifies the subscription to cancel. It is the value returned from
            the subscribe command.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: upnpResponseEvent
        """

        header = {
            "namespace": "upnpAudioIn",
            "command": "unsubscribe",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if logicalSID is None:
                missing_list.append('logicalSID')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'logicalSID': logicalSID,
        }

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]


# This class was automatically generated and should only be edited via namespace-client.py.template
class upnpContentDirectoryClient(object):
    """
    Sonos was originally built around UPnP, which is a technology designed before the advent
    of cloud computing. UPnP does a lot of things well, but a fundamental design flaw is that
    UPnP trusts the local area network. Additionally, the use of XML and SOAP has fallen out
    of favor. As a result, Sonos decided to move onto a new control API nicknamed muse. Muse
    is built on REST, WebSocket, and JSON technology. It has been designed with security and
    cloud requirements. The time has come for Sonos to transition away from UPnP. However, the
    muse stack is not as broad as the UPnP stack.

    This private namespace is used to execute UPnP commands over a muse transport. Thus, Sonos
    can transition the controller to a modern transport. This plan is
    more expedient than implementing all of the UPnP functionality in muse _and_ changing the
    controller to use muse commands wholesale. This intermediate transition plan allows Sonos
    to maintain all of the controller business logic while changing the transport layer.

    The namespace is only available on the LAN, because UPnP is only used on the LAN. Muse v2
    is scheduled for the early part of 2020. The updated protocol will require tokens
    for every command on the LAN and incorporate the new identity backend.

    At this time, UPnP events are delivered via the traditional UPnP post-back URL. This decision
    was made to limit controller impact. Delivering muse events requires a persistent WebSocket
    connection today, which is outside of the initial scope.

    This namespace exposes the UPnP ContentDirectory1 service. We are providing specific namespaces
    per service in order to limit security access to different functionality.
    """

    def __init__(self, museWebsocketClient):
        self._museConnection = museWebsocketClient

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def call(self, method=None, headers=None, input=None, output=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use this command to execute a single UPnP command on the local player.

        This method was autogenerated from the upnpContentDirectory namespace xml definition
        :param method: (Required) This is the UPnP method name.
        :param headers: (Optional) Custom headers to add to the UPnP command. The product code imposes a maximum bytes size, rather
            than a maximum number of headers. Six seems like a good starting point.

            The headers should be added as name / value pairs: "X-Sonos-Header-Name: Header Value"
        :param input: (Optional) UPnP input parameters.
        :param output: (Optional) UPnP output parameter names.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: upnpResponseEvent
        """

        header = {
            "namespace": "upnpContentDirectory",
            "command": "call",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if method is None:
                missing_list.append('method')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'method': method,
        }

        # Only send optional parameters if they have a value
        if headers is not None:
            body["headers"] = headers
        if input is not None:
            body["input"] = input
        if output is not None:
            body["output"] = output

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def subscribe(self, durationSecs=None, port=None, eventPath=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        UPnP clients use this interface to request event notifications. The UPnP events are
        delivered out of band, using the traditional UPnP path. The parameters set the TCP
        port and HTTP URI path on which the client wants notifications. The IP address is
        inferred from the incoming connection.

        This method was autogenerated from the upnpContentDirectory namespace xml definition
        :param durationSecs: (Optional) This is desired the subscription duration in seconds. The player may override this
            value, in which case the actual duration is returned in the response.
        :param port: (Optional) This is the TCP port on which the client is hosting the HTTP service where
            UPnP notifications should be posted. Required when subscribing over REST.
        :param eventPath: (Optional) This is the URL path where the player posts UPnP notifications. The complete URL
            is formed by combining the client IP address, the port parameter and this path.
            This parameter is required when subscribing over REST.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: upnpResponseEvent
        """

        header = {
            "namespace": "upnpContentDirectory",
            "command": "subscribe",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        # Only send optional parameters if they have a value
        if durationSecs is not None:
            body["durationSecs"] = durationSecs
        if port is not None:
            body["port"] = port
        if eventPath is not None:
            body["eventPath"] = eventPath

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def renew(self, logicalSID=None, durationSecs=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        This interface is used to refresh subscriptions.

        This method was autogenerated from the upnpContentDirectory namespace xml definition
        :param logicalSID: (Required) This parameter identifies the subscription to renew. It is the value returned from
            the subscribe command.
        :param durationSecs: (Optional) This is desired the subscription duration in seconds. The player may override this
            value, in which case the actual duration is returned in the response.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: upnpResponseEvent
        """

        header = {
            "namespace": "upnpContentDirectory",
            "command": "renew",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if logicalSID is None:
                missing_list.append('logicalSID')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'logicalSID': logicalSID,
        }

        # Only send optional parameters if they have a value
        if durationSecs is not None:
            body["durationSecs"] = durationSecs

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def unsubscribe(self, logicalSID=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use this interface to cancel a subscription. The server will stop posting events
        after processing this command.

        This method was autogenerated from the upnpContentDirectory namespace xml definition
        :param logicalSID: (Required) This parameter identifies the subscription to cancel. It is the value returned from
            the subscribe command.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: upnpResponseEvent
        """

        header = {
            "namespace": "upnpContentDirectory",
            "command": "unsubscribe",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if logicalSID is None:
                missing_list.append('logicalSID')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'logicalSID': logicalSID,
        }

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]


# This class was automatically generated and should only be edited via namespace-client.py.template
class upnpHTControlClient(object):
    """
    Sonos was originally built around UPnP, which is a technology designed before the advent
    of cloud computing. UPnP does a lot of things well, but a fundamental design flaw is that
    UPnP trusts the local area network. Additionally, the use of XML and SOAP has fallen out
    of favor. As a result, Sonos decided to move onto a new control API nicknamed muse. Muse
    is built on REST, WebSocket, and JSON technology. It has been designed with security and
    cloud requirements. The time has come for Sonos to transition away from UPnP. However, the
    muse stack is not as broad as the UPnP stack.

    This private namespace is used to execute UPnP commands over a muse transport. Thus, Sonos
    can transition the controller to a modern transport. This plan is
    more expedient than implementing all of the UPnP functionality in muse _and_ changing the
    controller to use muse commands wholesale. This intermediate transition plan allows Sonos
    to maintain all of the controller business logic while changing the transport layer.

    The namespace is only available on the LAN, because UPnP is only used on the LAN. Muse v2
    is scheduled for the early part of 2020. The updated protocol will require tokens
    for every command on the LAN and incorporate the new identity backend.

    At this time, UPnP events are delivered via the traditional UPnP post-back URL. This decision
    was made to limit controller impact. Delivering muse events requires a persistent WebSocket
    connection today, which is outside of the initial scope.

    This namespace exposes the UPnP HTControl1 service. We are providing specific namespaces
    per service in order to limit security access to different functionality.
    """

    def __init__(self, museWebsocketClient):
        self._museConnection = museWebsocketClient

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def call(self, method=None, headers=None, input=None, output=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use this command to execute a single UPnP command on the local player.

        This method was autogenerated from the upnpHTControl namespace xml definition
        :param method: (Required) This is the UPnP method name.
        :param headers: (Optional) Custom headers to add to the UPnP command. The product code imposes a maximum bytes size, rather
            than a maximum number of headers. Six seems like a good starting point.

            The headers should be added as name / value pairs: "X-Sonos-Header-Name: Header Value"
        :param input: (Optional) UPnP input parameters.
        :param output: (Optional) UPnP output parameter names.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: upnpResponseEvent
        """

        header = {
            "namespace": "upnpHTControl",
            "command": "call",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if method is None:
                missing_list.append('method')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'method': method,
        }

        # Only send optional parameters if they have a value
        if headers is not None:
            body["headers"] = headers
        if input is not None:
            body["input"] = input
        if output is not None:
            body["output"] = output

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def subscribe(self, durationSecs=None, port=None, eventPath=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        UPnP clients use this interface to request event notifications. The UPnP events are
        delivered out of band, using the traditional UPnP path. The parameters set the TCP
        port and HTTP URI path on which the client wants notifications. The IP address is
        inferred from the incoming connection.

        This method was autogenerated from the upnpHTControl namespace xml definition
        :param durationSecs: (Optional) This is desired the subscription duration in seconds. The player may override this
            value, in which case the actual duration is returned in the response.
        :param port: (Optional) This is the TCP port on which the client is hosting the HTTP service where
            UPnP notifications should be posted. Required when subscribing over REST.
        :param eventPath: (Optional) This is the URL path where the player posts UPnP notifications. The complete URL
            is formed by combining the client IP address, the port parameter and this path.
            This parameter is required when subscribing over REST.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: upnpResponseEvent
        """

        header = {
            "namespace": "upnpHTControl",
            "command": "subscribe",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        # Only send optional parameters if they have a value
        if durationSecs is not None:
            body["durationSecs"] = durationSecs
        if port is not None:
            body["port"] = port
        if eventPath is not None:
            body["eventPath"] = eventPath

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def renew(self, logicalSID=None, durationSecs=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        This interface is used to refresh subscriptions.

        This method was autogenerated from the upnpHTControl namespace xml definition
        :param logicalSID: (Required) This parameter identifies the subscription to renew. It is the value returned from
            the subscribe command.
        :param durationSecs: (Optional) This is desired the subscription duration in seconds. The player may override this
            value, in which case the actual duration is returned in the response.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: upnpResponseEvent
        """

        header = {
            "namespace": "upnpHTControl",
            "command": "renew",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if logicalSID is None:
                missing_list.append('logicalSID')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'logicalSID': logicalSID,
        }

        # Only send optional parameters if they have a value
        if durationSecs is not None:
            body["durationSecs"] = durationSecs

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def unsubscribe(self, logicalSID=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use this interface to cancel a subscription. The server will stop posting events
        after processing this command.

        This method was autogenerated from the upnpHTControl namespace xml definition
        :param logicalSID: (Required) This parameter identifies the subscription to cancel. It is the value returned from
            the subscribe command.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: upnpResponseEvent
        """

        header = {
            "namespace": "upnpHTControl",
            "command": "unsubscribe",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if logicalSID is None:
                missing_list.append('logicalSID')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'logicalSID': logicalSID,
        }

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]


# This class was automatically generated and should only be edited via namespace-client.py.template
class upnpMusicServicesClient(object):
    """
    Sonos was originally built around UPnP, which is a technology designed before the advent
    of cloud computing. UPnP does a lot of things well, but a fundamental design flaw is that
    UPnP trusts the local area network. Additionally, the use of XML and SOAP has fallen out
    of favor. As a result, Sonos decided to move onto a new control API nicknamed muse. Muse
    is built on REST, WebSocket, and JSON technology. It has been designed with security and
    cloud requirements. The time has come for Sonos to transition away from UPnP. However, the
    muse stack is not as broad as the UPnP stack.

    This private namespace is used to execute UPnP commands over a muse transport. Thus, Sonos
    can transition the controller to a modern transport. This plan is
    more expedient than implementing all of the UPnP functionality in muse _and_ changing the
    controller to use muse commands wholesale. This intermediate transition plan allows Sonos
    to maintain all of the controller business logic while changing the transport layer.

    The namespace is only available on the LAN, because UPnP is only used on the LAN. Muse v2
    is scheduled for the early part of 2020. The updated protocol will require tokens
    for every command on the LAN and incorporate the new identity backend.

    At this time, UPnP events are delivered via the traditional UPnP post-back URL. This decision
    was made to limit controller impact. Delivering muse events requires a persistent WebSocket
    connection today, which is outside of the initial scope.

    This namespace exposes the UPnP MusicServices1 service. We are providing specific namespaces
    per service in order to limit security access to different functionality.
    """

    def __init__(self, museWebsocketClient):
        self._museConnection = museWebsocketClient

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def call(self, method=None, headers=None, input=None, output=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use this command to execute a single UPnP command on the local player.

        This method was autogenerated from the upnpMusicServices namespace xml definition
        :param method: (Required) This is the UPnP method name.
        :param headers: (Optional) Custom headers to add to the UPnP command. The product code imposes a maximum bytes size, rather
            than a maximum number of headers. Six seems like a good starting point.

            The headers should be added as name / value pairs: "X-Sonos-Header-Name: Header Value"
        :param input: (Optional) UPnP input parameters.
        :param output: (Optional) UPnP output parameter names.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: upnpResponseEvent
        """

        header = {
            "namespace": "upnpMusicServices",
            "command": "call",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if method is None:
                missing_list.append('method')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'method': method,
        }

        # Only send optional parameters if they have a value
        if headers is not None:
            body["headers"] = headers
        if input is not None:
            body["input"] = input
        if output is not None:
            body["output"] = output

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def subscribe(self, durationSecs=None, port=None, eventPath=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        UPnP clients use this interface to request event notifications. The UPnP events are
        delivered out of band, using the traditional UPnP path. The parameters set the TCP
        port and HTTP URI path on which the client wants notifications. The IP address is
        inferred from the incoming connection.

        This method was autogenerated from the upnpMusicServices namespace xml definition
        :param durationSecs: (Optional) This is desired the subscription duration in seconds. The player may override this
            value, in which case the actual duration is returned in the response.
        :param port: (Optional) This is the TCP port on which the client is hosting the HTTP service where
            UPnP notifications should be posted. Required when subscribing over REST.
        :param eventPath: (Optional) This is the URL path where the player posts UPnP notifications. The complete URL
            is formed by combining the client IP address, the port parameter and this path.
            This parameter is required when subscribing over REST.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: upnpResponseEvent
        """

        header = {
            "namespace": "upnpMusicServices",
            "command": "subscribe",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        # Only send optional parameters if they have a value
        if durationSecs is not None:
            body["durationSecs"] = durationSecs
        if port is not None:
            body["port"] = port
        if eventPath is not None:
            body["eventPath"] = eventPath

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def renew(self, logicalSID=None, durationSecs=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        This interface is used to refresh subscriptions.

        This method was autogenerated from the upnpMusicServices namespace xml definition
        :param logicalSID: (Required) This parameter identifies the subscription to renew. It is the value returned from
            the subscribe command.
        :param durationSecs: (Optional) This is desired the subscription duration in seconds. The player may override this
            value, in which case the actual duration is returned in the response.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: upnpResponseEvent
        """

        header = {
            "namespace": "upnpMusicServices",
            "command": "renew",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if logicalSID is None:
                missing_list.append('logicalSID')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'logicalSID': logicalSID,
        }

        # Only send optional parameters if they have a value
        if durationSecs is not None:
            body["durationSecs"] = durationSecs

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def unsubscribe(self, logicalSID=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use this interface to cancel a subscription. The server will stop posting events
        after processing this command.

        This method was autogenerated from the upnpMusicServices namespace xml definition
        :param logicalSID: (Required) This parameter identifies the subscription to cancel. It is the value returned from
            the subscribe command.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: upnpResponseEvent
        """

        header = {
            "namespace": "upnpMusicServices",
            "command": "unsubscribe",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if logicalSID is None:
                missing_list.append('logicalSID')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'logicalSID': logicalSID,
        }

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]


# This class was automatically generated and should only be edited via namespace-client.py.template
class upnpQueueClient(object):
    """
    Sonos was originally built around UPnP, which is a technology designed before the advent
    of cloud computing. UPnP does a lot of things well, but a fundamental design flaw is that
    UPnP trusts the local area network. Additionally, the use of XML and SOAP has fallen out
    of favor. As a result, Sonos decided to move onto a new control API nicknamed muse. Muse
    is built on REST, WebSocket, and JSON technology. It has been designed with security and
    cloud requirements. The time has come for Sonos to transition away from UPnP. However, the
    muse stack is not as broad as the UPnP stack.

    This private namespace is used to execute UPnP commands over a muse transport. Thus, Sonos
    can transition the controller to a modern transport. This plan is
    more expedient than implementing all of the UPnP functionality in muse _and_ changing the
    controller to use muse commands wholesale. This intermediate transition plan allows Sonos
    to maintain all of the controller business logic while changing the transport layer.

    The namespace is only available on the LAN, because UPnP is only used on the LAN. Muse v2
    is scheduled for the early part of 2020. The updated protocol will require tokens
    for every command on the LAN and incorporate the new identity backend.

    At this time, UPnP events are delivered via the traditional UPnP post-back URL. This decision
    was made to limit controller impact. Delivering muse events requires a persistent WebSocket
    connection today, which is outside of the initial scope.

    This namespace exposes the UPnP Queue1 service. We are providing specific namespaces
    per service in order to limit security access to different functionality.
    """

    def __init__(self, museWebsocketClient):
        self._museConnection = museWebsocketClient

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def call(self, method=None, headers=None, input=None, output=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use this command to execute a single UPnP command on the local player.

        This method was autogenerated from the upnpQueue namespace xml definition
        :param method: (Required) This is the UPnP method name.
        :param headers: (Optional) Custom headers to add to the UPnP command. The product code imposes a maximum bytes size, rather
            than a maximum number of headers. Six seems like a good starting point.

            The headers should be added as name / value pairs: "X-Sonos-Header-Name: Header Value"
        :param input: (Optional) UPnP input parameters.
        :param output: (Optional) UPnP output parameter names.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: upnpResponseEvent
        """

        header = {
            "namespace": "upnpQueue",
            "command": "call",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if method is None:
                missing_list.append('method')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'method': method,
        }

        # Only send optional parameters if they have a value
        if headers is not None:
            body["headers"] = headers
        if input is not None:
            body["input"] = input
        if output is not None:
            body["output"] = output

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def subscribe(self, durationSecs=None, port=None, eventPath=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        UPnP clients use this interface to request event notifications. The UPnP events are
        delivered out of band, using the traditional UPnP path. The parameters set the TCP
        port and HTTP URI path on which the client wants notifications. The IP address is
        inferred from the incoming connection.

        This method was autogenerated from the upnpQueue namespace xml definition
        :param durationSecs: (Optional) This is desired the subscription duration in seconds. The player may override this
            value, in which case the actual duration is returned in the response.
        :param port: (Optional) This is the TCP port on which the client is hosting the HTTP service where
            UPnP notifications should be posted. Required when subscribing over REST.
        :param eventPath: (Optional) This is the URL path where the player posts UPnP notifications. The complete URL
            is formed by combining the client IP address, the port parameter and this path.
            This parameter is required when subscribing over REST.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: upnpResponseEvent
        """

        header = {
            "namespace": "upnpQueue",
            "command": "subscribe",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        # Only send optional parameters if they have a value
        if durationSecs is not None:
            body["durationSecs"] = durationSecs
        if port is not None:
            body["port"] = port
        if eventPath is not None:
            body["eventPath"] = eventPath

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def renew(self, logicalSID=None, durationSecs=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        This interface is used to refresh subscriptions.

        This method was autogenerated from the upnpQueue namespace xml definition
        :param logicalSID: (Required) This parameter identifies the subscription to renew. It is the value returned from
            the subscribe command.
        :param durationSecs: (Optional) This is desired the subscription duration in seconds. The player may override this
            value, in which case the actual duration is returned in the response.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: upnpResponseEvent
        """

        header = {
            "namespace": "upnpQueue",
            "command": "renew",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if logicalSID is None:
                missing_list.append('logicalSID')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'logicalSID': logicalSID,
        }

        # Only send optional parameters if they have a value
        if durationSecs is not None:
            body["durationSecs"] = durationSecs

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def unsubscribe(self, logicalSID=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use this interface to cancel a subscription. The server will stop posting events
        after processing this command.

        This method was autogenerated from the upnpQueue namespace xml definition
        :param logicalSID: (Required) This parameter identifies the subscription to cancel. It is the value returned from
            the subscribe command.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: upnpResponseEvent
        """

        header = {
            "namespace": "upnpQueue",
            "command": "unsubscribe",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if logicalSID is None:
                missing_list.append('logicalSID')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'logicalSID': logicalSID,
        }

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]


# This class was automatically generated and should only be edited via namespace-client.py.template
class upnpRenderingControlClient(object):
    """
    Sonos was originally built around UPnP, which is a technology designed before the advent
    of cloud computing. UPnP does a lot of things well, but a fundamental design flaw is that
    UPnP trusts the local area network. Additionally, the use of XML and SOAP has fallen out
    of favor. As a result, Sonos decided to move onto a new control API nicknamed muse. Muse
    is built on REST, WebSocket, and JSON technology. It has been designed with security and
    cloud requirements. The time has come for Sonos to transition away from UPnP. However, the
    muse stack is not as broad as the UPnP stack.

    This private namespace is used to execute UPnP commands over a muse transport. Thus, Sonos
    can transition the controller to a modern transport. This plan is
    more expedient than implementing all of the UPnP functionality in muse _and_ changing the
    controller to use muse commands wholesale. This intermediate transition plan allows Sonos
    to maintain all of the controller business logic while changing the transport layer.

    The namespace is only available on the LAN, because UPnP is only used on the LAN. Muse v2
    is scheduled for the early part of 2020. The updated protocol will require tokens
    for every command on the LAN and incorporate the new identity backend.

    At this time, UPnP events are delivered via the traditional UPnP post-back URL. This decision
    was made to limit controller impact. Delivering muse events requires a persistent WebSocket
    connection today, which is outside of the initial scope.

    This namespace exposes the UPnP RenderingControl1 service. We are providing specific namespaces
    per service in order to limit security access to different functionality.
    """

    def __init__(self, museWebsocketClient):
        self._museConnection = museWebsocketClient

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def call(self, method=None, headers=None, input=None, output=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use this command to execute a single UPnP command on the local player.

        This method was autogenerated from the upnpRenderingControl namespace xml definition
        :param method: (Required) This is the UPnP method name.
        :param headers: (Optional) Custom headers to add to the UPnP command. The product code imposes a maximum bytes size, rather
            than a maximum number of headers. Six seems like a good starting point.

            The headers should be added as name / value pairs: "X-Sonos-Header-Name: Header Value"
        :param input: (Optional) UPnP input parameters.
        :param output: (Optional) UPnP output parameter names.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: upnpResponseEvent
        """

        header = {
            "namespace": "upnpRenderingControl",
            "command": "call",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if method is None:
                missing_list.append('method')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'method': method,
        }

        # Only send optional parameters if they have a value
        if headers is not None:
            body["headers"] = headers
        if input is not None:
            body["input"] = input
        if output is not None:
            body["output"] = output

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def subscribe(self, durationSecs=None, port=None, eventPath=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        UPnP clients use this interface to request event notifications. The UPnP events are
        delivered out of band, using the traditional UPnP path. The parameters set the TCP
        port and HTTP URI path on which the client wants notifications. The IP address is
        inferred from the incoming connection.

        This method was autogenerated from the upnpRenderingControl namespace xml definition
        :param durationSecs: (Optional) This is desired the subscription duration in seconds. The player may override this
            value, in which case the actual duration is returned in the response.
        :param port: (Optional) This is the TCP port on which the client is hosting the HTTP service where
            UPnP notifications should be posted. Required when subscribing over REST.
        :param eventPath: (Optional) This is the URL path where the player posts UPnP notifications. The complete URL
            is formed by combining the client IP address, the port parameter and this path.
            This parameter is required when subscribing over REST.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: upnpResponseEvent
        """

        header = {
            "namespace": "upnpRenderingControl",
            "command": "subscribe",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        # Only send optional parameters if they have a value
        if durationSecs is not None:
            body["durationSecs"] = durationSecs
        if port is not None:
            body["port"] = port
        if eventPath is not None:
            body["eventPath"] = eventPath

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def renew(self, logicalSID=None, durationSecs=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        This interface is used to refresh subscriptions.

        This method was autogenerated from the upnpRenderingControl namespace xml definition
        :param logicalSID: (Required) This parameter identifies the subscription to renew. It is the value returned from
            the subscribe command.
        :param durationSecs: (Optional) This is desired the subscription duration in seconds. The player may override this
            value, in which case the actual duration is returned in the response.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: upnpResponseEvent
        """

        header = {
            "namespace": "upnpRenderingControl",
            "command": "renew",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if logicalSID is None:
                missing_list.append('logicalSID')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'logicalSID': logicalSID,
        }

        # Only send optional parameters if they have a value
        if durationSecs is not None:
            body["durationSecs"] = durationSecs

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def unsubscribe(self, logicalSID=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use this interface to cancel a subscription. The server will stop posting events
        after processing this command.

        This method was autogenerated from the upnpRenderingControl namespace xml definition
        :param logicalSID: (Required) This parameter identifies the subscription to cancel. It is the value returned from
            the subscribe command.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: upnpResponseEvent
        """

        header = {
            "namespace": "upnpRenderingControl",
            "command": "unsubscribe",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if logicalSID is None:
                missing_list.append('logicalSID')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'logicalSID': logicalSID,
        }

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]


# This class was automatically generated and should only be edited via namespace-client.py.template
class upnpSystemPropertiesClient(object):
    """
    Sonos was originally built around UPnP, which is a technology designed before the advent
    of cloud computing. UPnP does a lot of things well, but a fundamental design flaw is that
    UPnP trusts the local area network. Additionally, the use of XML and SOAP has fallen out
    of favor. As a result, Sonos decided to move onto a new control API nicknamed muse. Muse
    is built on REST, WebSocket, and JSON technology. It has been designed with security and
    cloud requirements. The time has come for Sonos to transition away from UPnP. However, the
    muse stack is not as broad as the UPnP stack.

    This private namespace is used to execute UPnP commands over a muse transport. Thus, Sonos
    can transition the controller to a modern transport. This plan is
    more expedient than implementing all of the UPnP functionality in muse _and_ changing the
    controller to use muse commands wholesale. This intermediate transition plan allows Sonos
    to maintain all of the controller business logic while changing the transport layer.

    The namespace is only available on the LAN, because UPnP is only used on the LAN. Muse v2
    is scheduled for the early part of 2020. The updated protocol will require tokens
    for every command on the LAN and incorporate the new identity backend.

    At this time, UPnP events are delivered via the traditional UPnP post-back URL. This decision
    was made to limit controller impact. Delivering muse events requires a persistent WebSocket
    connection today, which is outside of the initial scope.

    This namespace exposes the UPnP SystemProperties1 service. We are providing specific namespaces
    per service in order to limit security access to different functionality.
    """

    def __init__(self, museWebsocketClient):
        self._museConnection = museWebsocketClient

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def call(self, method=None, headers=None, input=None, output=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use this command to execute a single UPnP comomand on the local player.

        This method was autogenerated from the upnpSystemProperties namespace xml definition
        :param method: (Required) This is the UPnP method name.
        :param headers: (Optional) Custom headers to add to the UPnP command. The product code imposes a maximum bytes size, rather
            than a maximum number of headers. Six seems like a good starting point.

            The headers should be added as name / value pairs: "X-Sonos-Header-Name: Header Value"
        :param input: (Optional) UPnP input parameters.
        :param output: (Optional) UPnP output parameter names.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: upnpResponseEvent
        """

        header = {
            "namespace": "upnpSystemProperties",
            "command": "call",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if method is None:
                missing_list.append('method')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'method': method,
        }

        # Only send optional parameters if they have a value
        if headers is not None:
            body["headers"] = headers
        if input is not None:
            body["input"] = input
        if output is not None:
            body["output"] = output

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def subscribe(self, durationSecs=None, port=None, eventPath=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        UPnP clients use this interface to request event notifications. The UPnP events are
        delivered out of band, using the traditional UPnP path. The parameters set the TCP
        port and HTTP URI path on which the client wants notifications. The IP address is
        inferred from the incoming connection.

        This method was autogenerated from the upnpSystemProperties namespace xml definition
        :param durationSecs: (Optional) This is desired the subscription duration in seconds. The player may override this
            value, in which case the actual duration is returned in the response.
        :param port: (Optional) This is the TCP port on which the client is hosting the HTTP service where
            UPnP notifications should be posted. Required when subscribing over REST.
        :param eventPath: (Optional) This is the URL path where the player posts UPnP notifications. The complete URL
            is formed by combining the client IP address, the port parameter and this path.
            This parameter is required when subscribing over REST.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: upnpResponseEvent
        """

        header = {
            "namespace": "upnpSystemProperties",
            "command": "subscribe",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        # Only send optional parameters if they have a value
        if durationSecs is not None:
            body["durationSecs"] = durationSecs
        if port is not None:
            body["port"] = port
        if eventPath is not None:
            body["eventPath"] = eventPath

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def renew(self, logicalSID=None, durationSecs=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        This interface is used to refresh subscriptions.

        This method was autogenerated from the upnpSystemProperties namespace xml definition
        :param logicalSID: (Required) This parameter identifies the subscription to renew. It is the value returned from
            the subscribe command.
        :param durationSecs: (Optional) This is desired the subscription duration in seconds. The player may override this
            value, in which case the actual duration is returned in the response.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: upnpResponseEvent
        """

        header = {
            "namespace": "upnpSystemProperties",
            "command": "renew",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if logicalSID is None:
                missing_list.append('logicalSID')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'logicalSID': logicalSID,
        }

        # Only send optional parameters if they have a value
        if durationSecs is not None:
            body["durationSecs"] = durationSecs

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def unsubscribe(self, logicalSID=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use this interface to cancel a subscription. The server will stop posting events
        after processing this command.

        This method was autogenerated from the upnpSystemProperties namespace xml definition
        :param logicalSID: (Required) This parameter identifies the subscription to cancel. It is the value returned from
            the subscribe command.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: upnpResponseEvent
        """

        header = {
            "namespace": "upnpSystemProperties",
            "command": "unsubscribe",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if logicalSID is None:
                missing_list.append('logicalSID')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'logicalSID': logicalSID,
        }

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]


# This class was automatically generated and should only be edited via namespace-client.py.template
class upnpZoneGroupTopologyClient(object):
    """
    Sonos was originally built around UPnP, which is a technology designed before the advent
    of cloud computing. UPnP does a lot of things well, but a fundamental design flaw is that
    UPnP trusts the local area network. Additionally, the use of XML and SOAP has fallen out
    of favor. As a result, Sonos decided to move onto a new control API nicknamed muse. Muse
    is built on REST, WebSocket, and JSON technology. It has been designed with security and
    cloud requirements. The time has come for Sonos to transition away from UPnP. However, the
    muse stack is not as broad as the UPnP stack.

    This private namespace is used to execute UPnP commands over a muse transport. Thus, Sonos
    can transition the controller to a modern transport. This plan is
    more expedient than implementing all of the UPnP functionality in muse _and_ changing the
    controller to use muse commands wholesale. This intermediate transition plan allows Sonos
    to maintain all of the controller business logic while changing the transport layer.

    The namespace is only available on the LAN, because UPnP is only used on the LAN. Muse v2
    is scheduled for the early part of 2020. The updated protocol will require tokens
    for every command on the LAN and incorporate the new identity backend.

    At this time, UPnP events are delivered via the traditional UPnP post-back URL. This decision
    was made to limit controller impact. Delivering muse events requires a persistent WebSocket
    connection today, which is outside of the initial scope.

    This namespace exposes the UPnP ZoneGroupTopology1 service. We are providing specific namespaces
    per service in order to limit security access to different functionality.
    """

    def __init__(self, museWebsocketClient):
        self._museConnection = museWebsocketClient

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def call(self, method=None, headers=None, input=None, output=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use this command to execute a single UPnP command on the local player.

        This method was autogenerated from the upnpZoneGroupTopology namespace xml definition
        :param method: (Required) This is the UPnP method name.
        :param headers: (Optional) Custom headers to add to the UPnP command. The product code imposes a maximum bytes size, rather
            than a maximum number of headers. Six seems like a good starting point.

            The headers should be added as name / value pairs: "X-Sonos-Header-Name: Header Value"
        :param input: (Optional) UPnP input parameters.
        :param output: (Optional) UPnP output parameter names.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: upnpResponseEvent
        """

        header = {
            "namespace": "upnpZoneGroupTopology",
            "command": "call",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if method is None:
                missing_list.append('method')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'method': method,
        }

        # Only send optional parameters if they have a value
        if headers is not None:
            body["headers"] = headers
        if input is not None:
            body["input"] = input
        if output is not None:
            body["output"] = output

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def subscribe(self, durationSecs=None, port=None, eventPath=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        UPnP clients use this interface to request event notifications. The UPnP events are
        delivered out of band, using the traditional UPnP path. The parameters set the TCP
        port and HTTP URI path on which the client wants notifications. The IP address is
        inferred from the incoming connection.

        This method was autogenerated from the upnpZoneGroupTopology namespace xml definition
        :param durationSecs: (Optional) This is desired the subscription duration in seconds. The player may override this
            value, in which case the actual duration is returned in the response.
        :param port: (Optional) This is the TCP port on which the client is hosting the HTTP service where
            UPnP notifications should be posted. Required when subscribing over REST.
        :param eventPath: (Optional) This is the URL path where the player posts UPnP notifications. The complete URL
            is formed by combining the client IP address, the port parameter and this path.
            This parameter is required when subscribing over REST.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: upnpResponseEvent
        """

        header = {
            "namespace": "upnpZoneGroupTopology",
            "command": "subscribe",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        # Only send optional parameters if they have a value
        if durationSecs is not None:
            body["durationSecs"] = durationSecs
        if port is not None:
            body["port"] = port
        if eventPath is not None:
            body["eventPath"] = eventPath

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def renew(self, logicalSID=None, durationSecs=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        This interface is used to refresh subscriptions.

        This method was autogenerated from the upnpZoneGroupTopology namespace xml definition
        :param logicalSID: (Required) This parameter identifies the subscription to renew. It is the value returned from
            the subscribe command.
        :param durationSecs: (Optional) This is desired the subscription duration in seconds. The player may override this
            value, in which case the actual duration is returned in the response.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: upnpResponseEvent
        """

        header = {
            "namespace": "upnpZoneGroupTopology",
            "command": "renew",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if logicalSID is None:
                missing_list.append('logicalSID')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'logicalSID': logicalSID,
        }

        # Only send optional parameters if they have a value
        if durationSecs is not None:
            body["durationSecs"] = durationSecs

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def unsubscribe(self, logicalSID=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Use this interface to cancel a subscription. The server will stop posting events
        after processing this command.

        This method was autogenerated from the upnpZoneGroupTopology namespace xml definition
        :param logicalSID: (Required) This parameter identifies the subscription to cancel. It is the value returned from
            the subscribe command.
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: upnpResponseEvent
        """

        header = {
            "namespace": "upnpZoneGroupTopology",
            "command": "unsubscribe",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if logicalSID is None:
                missing_list.append('logicalSID')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'logicalSID': logicalSID,
        }

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]


# This class was automatically generated and should only be edited via namespace-client.py.template
class voiceClient(object):
    """
    This namespace enables client applications (including the Sonos controller) to create, retrieve,
    update, and delete voice accounts on players with microphones.

    Commands in this namespace are player targeted, by default.
    """

    def __init__(self, museWebsocketClient):
        self._museConnection = museWebsocketClient

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def getVoiceAccounts(self, oauthToken=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        This command fetches all of the voice accounts.

        This method was autogenerated from the voice namespace xml definition
        :param oauthToken: (Required) HH_CONFIG_ADMIN scoped oauth token
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: voiceAccountsListEvent globalErrorEvent
        """

        header = {
            "namespace": "voice",
            "command": "getVoiceAccounts",
            "playerId": self._museConnection.uuid
        }

        oauthToken = self._museConnection.hhConfigAdminToken if oauthToken is None else oauthToken
        # Verified required oauthToken param is not None
        assert oauthToken is not None, "Command requires an oauthToken param"
        header["authorization"] = "bearer {}".format(oauthToken)
        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def createVoiceAccount(self, service=None, nickname=None, oauthToken=None, wakeword=None, amazon=None, status=None, timeoutSeconds=None, allowVoiceDataCollection=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        This commands creates a new voice account. There are runtime configuration constraints.

        1. Active voice accounts are not supported on satellite speakers in home theater configurations
           where the primary device (beam) has a microphone.

        The error code, ERROR_DISALLOWED_BY_POLICY, is returned when the runtime constraints are violated.

        This method was autogenerated from the voice namespace xml definition
        :param service: (Required)
        :param nickname: (Required)
        :param wakeword: (Optional)
        :param amazon: (Optional)
        :param status: (Optional)
        :param timeoutSeconds: (Optional)
        :param allowVoiceDataCollection: (Optional)
        :param oauthToken: (Required) HH_CONFIG_ADMIN scoped oauth token
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: accountErrorEvent voiceAccountEvent globalErrorEvent
        """

        header = {
            "namespace": "voice",
            "command": "createVoiceAccount",
            "playerId": self._museConnection.uuid
        }

        oauthToken = self._museConnection.hhConfigAdminToken if oauthToken is None else oauthToken
        # Verified required oauthToken param is not None
        assert oauthToken is not None, "Command requires an oauthToken param"
        header["authorization"] = "bearer {}".format(oauthToken)
        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if service is None:
                missing_list.append('service')
            if nickname is None:
                missing_list.append('nickname')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'service': service,
            'nickname': nickname,
        }

        # Only send optional parameters if they have a value
        if wakeword is not None:
            body["wakeword"] = wakeword
        if amazon is not None:
            body["amazon"] = amazon
        if status is not None:
            body["status"] = status
        if timeoutSeconds is not None:
            body["timeoutSeconds"] = timeoutSeconds
        if allowVoiceDataCollection is not None:
            body["allowVoiceDataCollection"] = allowVoiceDataCollection

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def updateVoiceAccount(self, accountId=None, oauthToken=None, wakeword=None, status=None, allowVoiceDataCollection=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        This command updates a voice account. It can be used to:

        - customize the wakeword
        - activate an account
        - deactivate an account
        - enable or disable voice data collection (only applies to alpha builds)

        There are runtime configuration constraints.

        1. Active voice accounts are not supported on satellite speakers in home theater configurations
           where the primary device (beam) has a microphone.

        The error code, ERROR_DISALLOWED_BY_POLICY, is returned when the runtime constraints are violated.

        This method was autogenerated from the voice namespace xml definition
        :param accountId: (Required)
        :param wakeword: (Optional)
        :param status: (Optional)
        :param allowVoiceDataCollection: (Optional)
        :param oauthToken: (Required) HH_CONFIG_ADMIN scoped oauth token
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: accountErrorEvent voiceAccountEvent globalErrorEvent
        """

        header = {
            "namespace": "voice",
            "command": "updateVoiceAccount",
            "playerId": self._museConnection.uuid
        }

        oauthToken = self._museConnection.hhConfigAdminToken if oauthToken is None else oauthToken
        # Verified required oauthToken param is not None
        assert oauthToken is not None, "Command requires an oauthToken param"
        header["authorization"] = "bearer {}".format(oauthToken)
        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if accountId is None:
                missing_list.append('accountId')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'accountId': accountId,
        }

        # Only send optional parameters if they have a value
        if wakeword is not None:
            body["wakeword"] = wakeword
        if status is not None:
            body["status"] = status
        if allowVoiceDataCollection is not None:
            body["allowVoiceDataCollection"] = allowVoiceDataCollection

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def removeVoiceAccount(self, accountId=None, oauthToken=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        This command removes a voice account from the system.

        This method was autogenerated from the voice namespace xml definition
        :param accountId: (Required)
        :param oauthToken: (Required) HH_CONFIG_ADMIN scoped oauth token
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: accountErrorEvent globalErrorEvent
        """

        header = {
            "namespace": "voice",
            "command": "removeVoiceAccount",
            "playerId": self._museConnection.uuid
        }

        oauthToken = self._museConnection.hhConfigAdminToken if oauthToken is None else oauthToken
        # Verified required oauthToken param is not None
        assert oauthToken is not None, "Command requires an oauthToken param"
        header["authorization"] = "bearer {}".format(oauthToken)
        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if accountId is None:
                missing_list.append('accountId')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'accountId': accountId,
        }

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def notifyInitiateOnboarding(self, service=None, oauthToken=None, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        This command notifies the system to initiate continued setup / onboarding for the specified voice service.

        This method was autogenerated from the voice namespace xml definition
        :param service: (Required)
        :param oauthToken: (Required) HH_CONFIG_ADMIN scoped oauth token
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: globalErrorEvent
        """

        header = {
            "namespace": "voice",
            "command": "notifyInitiateOnboarding",
            "playerId": self._museConnection.uuid
        }

        oauthToken = self._museConnection.hhConfigAdminToken if oauthToken is None else oauthToken
        # Verified required oauthToken param is not None
        assert oauthToken is not None, "Command requires an oauthToken param"
        header["authorization"] = "bearer {}".format(oauthToken)
        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        # Missing required param(s) check
        # Throw exception iff ignoreRequiredParams==False
        if ignoreRequiredParams is False:
            missing_list = []
            if service is None:
                missing_list.append('service')

            if len(missing_list) > 0:
                raise TypeError("Required param(s): < {} > not found".format(', '.join(missing_list)))

        body = {
            'service': service,
        }

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def subscribe(self, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Start receiving for voiceAccountsVersionChange events.

        This method was autogenerated from the voice namespace xml definition
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: globalErrorEvent
        """

        header = {
            "namespace": "voice",
            "command": "subscribe",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]

    # This method was automatically generated and should only be edited via namespace-command.py.template
    def unsubscribe(self, sendCommand=True, cmdId=True, ignoreRequiredParams=False, **kwargs):
        """
        Stop receiving voiceAccountsVersionChange events.

        This method was autogenerated from the voice namespace xml definition
        :param ignoreRequiredParams: (Optional) If True, skip raising exception when required parameters are missing
                                     and remove sending of None body parameters
        :param sendCommand: (Optional) Whether to send the prepared websocket command or return the command dict
        :param cmdId: (Optional) Whether to inject a commandId header param
        :return: globalErrorEvent
        """

        header = {
            "namespace": "voice",
            "command": "unsubscribe",
            "playerId": self._museConnection.uuid
        }

        # Add cmdId to the header
        if cmdId:
            header["cmdId"] = str(self._museConnection.cmdId)

        body = {}

        if kwargs:
            for key, value in kwargs.iteritems():
                body[key] = value

        if sendCommand:
            self._museConnection.send([header, body])
        else:
            return [header, body]
